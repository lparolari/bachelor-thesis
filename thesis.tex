\documentclass[12pt,a4paper,openright]{book} % oneside

% ****************************************************************
%   PACKAGES
\usepackage{lmodern}         % font package.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[italian]{babel}  % italian latex typo conventions.
\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage{csquotes}        % needed by babel.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{listings}        % embed programming language in latex.
\usepackage{stmaryrd}        % symbols for theoretical computer science.
\usepackage{hhline}          % better horizontal lines in tabulars and arrays.
%%\usepackage{vmargin}         % various page dimensions.
\usepackage{hyperref}        % hypertext support.
\usepackage{makeidx}         % for creating indexes.
\usepackage{nicefrac}        % inline fractions.
\usepackage{marginnote}      % notes in the margin, even where \marginpar fails.
\usepackage{xr}              % references to other latex documents.
\usepackage{subfiles}        % multifile support.
\usepackage{geometry}        % interface for document dimension.
\usepackage{graphicx}        % enhanced support for graphics.
\usepackage{fancyhdr}        % extensive control of page headers and footers.
\usepackage{lipsum}          % generate dummy text.
\usepackage[
	backend=biber,
	style=numeric,
	citestyle=numeric  % numeric, alphabetic
]{biblatex}                  % bib management. %bibtex
\usepackage{minitoc}         % table of contents per chapter.
\usepackage{listings}        % code sections, http://ctan.org/pkg/listings
%\usepackage{showframe}      % shows page frames.
\usepackage{titlesec}        % change titles size.
\usepackage{algorithm}       % algorithm block.
\usepackage{algpseudocode}   % style for (autoimported) package algorithmicx.
\usepackage{float}           % float management.
\usepackage[toc,page]{appendix}  % appendix.
\usepackage{tcolorbox}
%\usepackage{minted}
\usepackage{tikz}            % flow chart.
%\usepackage{subcaption}      % needed by nested figures.

% ****************************************************************
%   CONFIGS
\hypersetup{                                  % hyperlinks color
  colorlinks=true, 
  urlcolor=blue, 
  linkcolor=blue
}
\dominitoc                                    % minitoc setup  
\lstset{                                      % listing setup
  basicstyle=\ttfamily,
  mathescape
}
\addto{\captionsitalian}{%                    % custom translations
  \renewcommand{\mtctitle}{Sommario}%
  \renewcommand{\appendixtocname}{Appendici}%
  \renewcommand{\appendixpagename}{Appendici}%
}
\newenvironment{dedication}                   % dedication setup
  {%\clearpage           % we want a new page          %% I commented this
   \thispagestyle{empty}% no header and footer
   \vspace*{\stretch{1}}% some space at the top
   \itshape             % the text is in italics
   \raggedleft          % flush to the right margin
  }
  {\par % end the paragraph
   \vspace{\stretch{3}} % space at bottom is three times that at the top
   \clearpage           % finish off the page
  }
\titleformat*{\subsubsection}{               % subsubsection size
  \large\bfseries
}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
	decorations.pathreplacing,decorations.pathmorphing,shapes,%
	matrix,shapes.symbols}
\tikzset{
                                   % flow chart
>=stealth',
punktchain/.style={
	rectangle, 
	rounded corners, 
	% fill=black!10,
	draw=black, very thick,
	text width=10em, 
	minimum height=3em, 
	text centered, 
	on chain},
line/.style={draw, thick, <-},
element/.style={
	tape,
	top color=white,
	bottom color=blue!50!black!60!,
	minimum width=8em,
	draw=blue!40!black!90, very thick,
	text width=10em, 
	minimum height=3.5em, 
	text centered, 
	on chain},
every join/.style={->, thick,shorten >=1pt},
decoration={brace},
tuborg/.style={decorate},
tubnode/.style={midway, right=2pt},
}


% ****************************************************************
%   RESOURCES
\subfile{prooftree}
\input{macros.tex}
\addbibresource{biblio.bib}


% **********************************************
% **********************************************
\begin{document}

%%% First page
\begin{titlepage}
    \begin{center}       
        \includegraphics[width=0.4\textwidth]{img/logo_unipr.png}

		\vspace{0.5cm}
		
		% *** university details
		\Large
        Dipartimento di Scienze Matematiche\\
        Fisiche ed Informatiche

        \vspace{0.5cm}
        
        \Large
        Corso di Laurea in Informatica 
		
		\vspace{1.2cm} 
 
 		% *** title
        \Huge
        \textbf{Progettazione e implementazione in Picat di un risolutore per vincoli insiemistici}
 
 		% *** subtitle
        \vspace{1cm}
        \LARGE
        Design and implementation in Picat of a set constraint solver 
 
        \vspace{1.2cm}
 
 		% *** authors
		\large Candidato: \Large\textbf{Luca Parolari}\\
		\large Relatore: \Large\textbf{Gianfranco Rossi}
	
		%\begin{minipage}{0.4\textwidth}
		%	\begin{flushleft}
		%		\large
		%		\textit{Author}\\
		%		B.J. \textsc{Blazkowicz} % Your name
		%	\end{flushleft}
		%\end{minipage}
		%
		%\begin{minipage}{0.4\textwidth}
		%	\begin{flushright}
		%		\large
		%		\textit{Supervisor}\\
		%		Dr. Caroline \textsc{Becker} % Supervisor's name
		%	\end{flushright}
		%\end{minipage}
		
        \vfill
 		
 		\large
        Tesi di Laurea in Informatica\\
        Anno Accademico 2018-2019
 
    \end{center}
\end{titlepage}

%%% Dedication
%\begin{dedication}
%A mio nonno.
%\end{dedication}

%%% TOC
\tableofcontents
\listoffigures

%\lhead[\fancyplain{}{}]{\fancyplain{}{\leftmark}} \chead{}
%\rhead{\thepage} \lfoot{} \cfoot{} \rfoot{}


%%% *******************************************************
%%% Introduzione
\chapter*{Introduzione}

\lipsum[1-4]


% TODO da definire
%%% *******************************************************
% Panoramica e background
%\chapter{Panormaica e background}
%
%\minitoc
%
%In questo capitolo si vuole dare un'infarinatura sull'ambito dei linguaggi trattati in questo lavoro di tesi.


%%% *******************************************************
% Linguaggi a vincoli basati su insiemi
\chapter{Linguaggio a vincoli basato su insiemi}
\label{ch:clpbasedlang}

\minitoc

In questo capitolo vene presentato e contestualizzato un linguaggio
orientato alla risoluzione di formule insiemistiche denominato
\lset{}. \lset{} è un linguaggio logico definito come parte del
linguaggio di programmazione logica a vincoli (o Constraint Logic
Programming, abbreviato CLP) \clpset{}.

\clpset{} (e quindi il suo linguaggio a vincoli \lset{}) è stato
implementato in Prolog nello strumento \setlog{} \cite{SetLog};
inoltre \lset{} è stato implementato in Java come parte della libreria
\jsetl{} \cite{JSetL}. Obiettivo principale di questo lavoro di tesi è
quello di dare un’implementazione di \lset{} utilizzando il linguaggio
di programmazione Picat \cite{PicatLang}.

Nella sezione \ref{sec:clpbasedlang_clp} è descritto il paradigma di
programmazione logico a vincoli in forma molto discorsiva ed
introduttiva, mentre in \ref{sec:clpbasedlang_lset} si dà una
presentazione di \lset{}: sintassi, semantica, il solver e regole di
riscrittura.

\section{Constraint Logic Programming}
\label{sec:clpbasedlang_clp}

Nel campo dell'informatica la logica trova molteplici applicazioni, in
particolare nell'ambito dell'intelligenza artificiale. La logica
classica si può suddividere in due classi principali: la \emph{logica
  proposizionale} e la \emph{logica dei predicati}.  I più comuni
linguaggi logici sono basati su un sottoinsieme della logica dei
predicati del primo ordine, che permette di garantire la correttezza
delle soluzioni ma non la terminazione del programma. Entrambe,
comunque, permettono di esprimere proposizioni (frasi) e relazioni tra
posizioni. La principale differenza tra le due è l'espressività. Ciò
che può essere espresso nella logica dei predicati può essere espresso
nella logica proposizionale, ma non viceversa. La logica dei predicati
consente di utilizzare \textbf{variabili} e quantificazioni su di
esse, mentre nella logica proposizionale non è possibile.

La logica dei predicati, sotto opportune ipotesi, può diventare un
vero e proprio linguaggio di programmazione, prendendo appunto il nome
di Logic Programming (abbreviato LP) (per approfondire i concetti di
programmazione logica si veda ad esempio \cite{Console97}).

Il Logic Programming è un paradigma di programmazione dove gli
statements del programma rappresentano fatti o regole, espressi
tramite qualche logica formale, di un problema. La logica viene
utilizzata come meccanismo formale per analizzare le inferenze in
termini di operazioni su espressioni simboliche, dedurre conseguenze
da un insieme di premesse, studiare la verità (o falsità) di un
insieme di proposizioni, data la verità (o falsità) di altre
proposizioni e dimostrare la validità di una teoria.

Spesso i linguaggi di programmazione di questo tipo adottano un
approccio dichiarativo, descrivendo solamente la forma della soluzione
e non la procedura per ottenerla (e.g., il Datalog). Per i linguaggi
come il Prolog o Picat invece l'approccio può essere ibrido: il
paradigma dichiarativo, imperativo e procedurale si intersecano
lasciando al programmatore la scelta del paradigma da utilizzare.

La programmazione logica a vincoli (CLP) estende la programmazione
logica introducendo il concetto di \emph{vincolo}. Un programma CLP
contiene fatti e regole come un programma LP, con la differenza che
nel programma CLP il corpo delle clausole può presentare vincoli. Per
i CLP il risultato di una dimostrazione è quindi un insieme di vincoli
(contraint store) e/o un valore letterale valido in quell'insieme di
vincoli.

La programmazione logica a vincoli può essere utilizzata per risolvere
\emph{Contraint Satisfaction Problem} (spesso abbreviato in
\emph{CSP}).

Un problema di soddisfacimento di vincoli è una tripla composta da
\begin{itemize}
	\item un insieme $X$ di variabili ${X_1, \ldots, X_n}$;
	\item un insieme $D$ di domini ${D_1, \ldots, D_n}$, uno per
          variabile;
	\item un insieme $C$ di vincoli che specificano le
          combinazioni di valori possibili per le variabili.
\end{itemize}

Ogni dominio $D_i$ specifica un insieme di valori possibili per la
variabile $X_i$. Dato che i CSP sono parametrici rispetto al dominio
dei vincoli, anche il supporto alla risolzuione lo diventa: da qui il
nome \clpset{}. Si utilizzerà per la loro risoluzione un’opportuna
istanza dello schema generale CLP. Ad esempio se il dominio è quello
degli insiemi allora si potrebbe utilizzare \clpset{}.

\section{Il linguaggio logico a vincoli \lset{}}
\label{sec:clpbasedlang_lset}

\lset{} è un linguaggio logico per la gestione di vincoli su
insiemi. \lset{} è stato inizialmente introdotto come parte del
linguaggio \clpset{} \cite{Dovier00}. Da un punto di vista più
generale \clpset{} è un istanza dei CLP sopra descritti, dove il
dominio di applicazione dei vincoli è quello insiemistico.

Uno degli obiettivi primari di \clpset{} è di essere molto flessibile
e fornire forme generali per la manipolazione di insiemi e relative
operazioni, in quanto la nozione di \emph{set} è una componente comune
nella progettazione di programmi, ma sono pochi i linguaggi che
forniscono gli insiemi come struttura dati elementare.  Sempre in
\cite{Dovier00} vengono menzionate alcune eccezioni di linguaggi che
si basano su insiemi: SETL, B ed il linguaggio Z, utilizzato per
descrivere la specifica formale di programmi. Qualche eccezione esiste
anche nel campo dei \emph{database deduttivi} e, più recentemente,
anche come \emph{general purpose programming language}. Ad ogni modo,
questi linguaggi impongono dei limiti sul tipo di insiemi espressibili
o sulle capacità computazionali degli stessi. Ad esempio, in molti
ambiti, si richiede che gli insiemi siano totalmente specificati: non
sono ammesse \emph{variabili} libere.

In \lset{} gli insiemi sono visti come un tipo di dato primitivo del
linguaggio, ovvero termini della logica del primo ordine. I predicati
predefiniti invece sono visti come vincoli predefiniti del linguaggio,
gestiti con procedure di risoluzione di vincoli. La classe di insiemi
considerata vuole essere molto generale: gli insiemi possono essere
annidati e/o parzialmente specificati. Gli insiemi parzialmente
specificati possono contenere variabili come elementi dell’insieme o
come parte dell’insieme stesso.

Di seguito si forniscono le specifiche di \lset{} definendone prima la
sintassi (\ref{subsec:clpbasedlang_lset_sintax}) e poi la semantica
informale (\ref{subsec:clpbasedlang_lset_semantics}). In
\ref{subsec:clpbasedlang_lset_solver} viene descritto il funzionamento
in termini astratti del risolutore di formule per questo linguaggio,
implementato in questo lavoro di tesi, mentre in
\ref{subsec:clpbasedlang_lset_rewriteeq},
\ref{subsec:clpbasedlang_lset_rewriteset} e
\ref{subsec:clpbasedlang_lset_rewriteneg} sono trattate
rispettivamente le regole di riscrittura per vincoli di uguaglianza,
vincoli su insiemi e vincoli negativi.

\subsection{Sintassi}
\label{subsec:clpbasedlang_lset_sintax}

La sintassi del linguaggio \lset{} si basa sui seguenti insiemi di simboli:

\begin{itemize}
	\item $\calF$ è un insieme di costanti e simboli di funzione
          definito da:
	\begin{itemize}
		\item $\emptyset \in \calF$,
		\item $\{ \cdot \mid \cdot \} \in \calF$ e $int \in
                  \calF$, simboli relazione binaria,
		\item $\calF_0 \subset \calF$, dove $\calF_0$ è un
                  insieme di costanti e simboli di funzione non
                  interpretati;
	\end{itemize}
	\item $\prod_C = \{ =, in, un, disj, set \}$, insieme di
          simboli di predicato;
	\item $\calV$ è un insieme numerabile di simboli di variabile.
\end{itemize}

I \calset{}-\textit{termini} sono termini costruiti a partire dai
simboli di $\calF$ e $\calV$ nel modo usuale. Ad esempio, i seguenti,
sono termini insiemistici ($set-terms$):
\begin{itemize}
	\item $\{1 \mid \emptyset \} \equiv \{1\}$
	\item $\{1 \mid \{2 \mid \emptyset \} \} \equiv \{1,2\}$
	\item $\{1 \mid \{2 \mid X \} \} \equiv \{1,2 \mid X \}$
	\item $\ldots$
\end{itemize}

I \calset{}-\textit{constraint} atomici (o primitivi) sono predicati
atomici costruiti a partire dai simboli di $\prod_C$ nel modo
usuale. Ad esempio, i seguenti, sono \calset{}-\textit{constraint}
primitivi:
\begin{itemize}
	\item $X = 1$
	\item $un(\{1\}, \emptyset, R)$
\end{itemize}

Le \calset{}-\textit{formule} (o \calset{}-\textit{constraint}
composti) sono combinazioni $\wedge$ (and) e $\vee$ (or) di
\calset{}-\textit{constraint} primitivi. Le seguenti formule sono
esempi di \calset{}-\textit{constraint} composti:
\begin{itemize}
	\item $1\ in\ R \land 1\ nin\ S \land un(R,S,T) \land T = \{X\}$
	\item $(X\ in S \land X\ neq 1) \lor (X\ nin S \land X = 1)$
\end{itemize}

\subsection{Semantica informale}
\label{subsec:clpbasedlang_lset_semantics}

La semantica intuitiva dei vari simboli in $\sum_{\mathcal{SET}}$ è la seguente:

\begin{itemize}
	\item $\emptyset$ rappresenta l’insieme vuoto;
	\item $\{\cdot\mid\cdot\}$ rappresenta il costruttore di
          insiemi definito come $\{t\mid s\} = \{t\}\ \cup s$;
	\item il predicato $=$ rappresenta la relazione di
          uguaglianza;
	\item il predicato \textit{in} rappresenta la relazione di
          appartenenza;
	\item il predicato \textit{un} rappresenta la relazione di
          unione; insiemistica definita come: $un(r,s,t) = true
          \Longleftrightarrow t = r \cup s$;
	\item il predicato \textit{disj} rappresenta la relazione di
          disgiunzione insiemistica definita come $disj(r,s) = true
          \Longleftrightarrow r \cap s = \emptyset$;
	\item il predicato \textit{set} controlla che il termine sia
          un insieme.
\end{itemize}
%\subsubsection{Vincoli}

\subsection{Il solver \satset{}}
\label{subsec:clpbasedlang_lset_solver}

La procedura \satset{} risolve i vincoli e rappresenta il solver del
linguaggio \lset{}. Il seguente algoritmo ne descrive la struttura:

\begin{algorithm}
	\caption{Procedura \satset{}}
	\begin{algorithmic}[1]
		\Procedure{\satset{$(C)$}}{}
		\State $C \gets $ \texttt{sort\_infer($C$)};
		\Repeat
		\State $C'$ $\gets C;$
		\Repeat
		\State $C'' \gets C;$
		\State $C \gets $ \texttt{STEP($C$)};
		\Until {$C$ = $C''$;}
		\State $C \gets $ \texttt{remove\_neq($C$)};
		\Until {$C'$ = $C$;}
		\State
		\State\Return $C$;
		\EndProcedure
	\end{algorithmic}
	\label{alg:pseudo_satset}
\end{algorithm}

Essenzialmente \satset{$(C)$} utilizza tre procedure:

\begin{itemize}
	\item \textbf{\texttt{sort\_infer}}: aggiunge alla
          \calset{}-\textit{formula} $C$ i vincoli \textbf{set} e
          \textbf{integer} per assicurare che gli oggetti utilizzati
          nei vincoli siano del tipo corretto.
	
	\item \textbf{\texttt{STEP}}: applica speciali \textit{regole
          di riscrittura} alla formula $C$ corrente e ritorna
          \textit{false} oppure la formula modificata. L'esecuzione di
          $STEP$ viene iterata fino ad arrivare ad ottenere una
          formula in forma irriducibile. Notare che $STEP$ ritorna
          $false$ se almeno uno dei vincoli in $C$ viene riscritto a
          $false$. Anche $STEP(false)$ ritorna $false$.
	
	\item \textbf{\texttt{remove\_neq}}: tratta l'eliminazione dei
          $\neq-constraints$ nel caso in cui coinvolgano variabili
          insiemistiche che appaiono anche in vincoli di unione in
          forma risolta.
\end{itemize}

Quando la computazione non-deterministica di $\satset{}(C)$ termina,
se il risultato è $false$ allora si può concludere che $C$ non è
soddisfacibile; al contrario, se nessuno dei vincoli in $C$ viene
riscritto a $false$ allora ogni soluzione generata da \satset{} è una
soluzione per $C$ e viceversa.

\subsection{Regole di riscrittura per vincoli di eguaglianza}
\label{subsec:clpbasedlang_lset_rewriteeq}

 \fixme{Almeno un esempio di riscrittura di un vincolo composto
   (semplice); ad esempio: {1,2}={X,Y} and X neq 1 oppure 1 in X and 1
   nin X}

Nelle sezioni successive sono riportate le regole di riscrittura
descritte in \cite{Rossi18}, trattate durante la realizzazione del
solver.

L'implementazione di queste regole in Picat è riportata al capitolo
\ref{ch:impl}.

\subsubsection{Il vincolo eq}

\textit{Sintassi:} $t_1 = t_2$.\\
\noindent\textit{Semantica informale:} $t_1$ e $t_2$ sono uguali.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:eq_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{=\textsubscript{\arabic{equation}}}

		If $x, y, t, t_i, u_i: \text{U}; A,B: \text{Set}$ then:

		\begin{equation}
		\dotx = \dotx \to true
		\end{equation}
		\begin{equation}
		\text{If } t \not\in \calV, t = \dotx \to \\ \dotx = t
		\end{equation}
		\begin{equation}
		\text{If} \dotA \not\in vars(t_1, \ldots, t_n), \dotA = \{ t_1, \ldots, t_n \} \to \dotA = \{ t_1, \ldots, t_n \sqcup N \}
		\end{equation}
		\begin{equation}
		\text{If} \dotx \in vars(t), \dotx = t \to false
		\end{equation}
		\begin{equation}
		\dotx = t \to \text{substitute $\dotx$ by $t$ in all others literals of the input formula}
		\end{equation}
		\begin{equation}
		\text{If} f \not\equiv g, f(t_1, \ldots, t_n) = g(t_1, \ldots, t_m) \to false
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ t_1, & \ldots, t_m \sqcup \dotA \} = \{u_1, \ldots, u_n \sqcup \dotA \} \to \\
		& t_1 = u_j \land \{ t_2, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots, u_{j_1}, u_{j+1}, \ldots, u_n \sqcup \dotA \} \\
		& \lor t_1 = u_j \land \{ t_1, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots, u_{j_1}, u_{j+1}, \ldots, u_n \sqcup \dotA \} \\
		& \lor t_1 = u_j \land \{ t_2, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots u_n \sqcup \dotA \} \\
		& \lor \dotA = \{ t_1 \sqcup N \} \land \{ t_2, \ldots, t_m \sqcup N \} = \{ u_1, \ldots, u_n \sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ x \sqcup & A \} = \{ y \sqcup B \} \to \\
		& x = y \land A = B \\
		& \lor x = y \land \{ x \sqcup A \} = B \\
		& \lor x = y \land A = \{ y \sqcup B \} \\
		& \lor A = \{ y \sqcup N \} \land \{ x \sqcup N \} = B
		\end{split}
		\end{equation}
		\begin{equation}
		f(t_1, \ldots, t_n) = f(u_1, \ldots, u_n) \to t_1 = u_1 \land \ldots \land t_1 = u_n
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di uguaglianza}
	\label{fig:eq_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotx = t$ e $\dotx$ non è contenuto ne in $t$ ne in
          altri letterali della fomula.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:eq_constraints}

\subsubsection{Il vincolo neq}

\textit{Sintassi:} $t_1 \neq t_2$.\\
\noindent\textit{Semantica informale:} $t_1$ è diverso da $t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:neq_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\neq$\textsubscript{\arabic{equation}}}

		If $t, t_i: \text{U}; A,B: \text{Set}$ then:

		\begin{equation}
		\text{If } t \text{ is a constant or } t \in \calV, t \neq t \to false
		\end{equation}
		\begin{equation}
		\text{If } t \not\in \calV, t \neq \dotx \to \dotx \neq t
		\end{equation}
		\begin{equation}
		\text{If} \dotx \not\in vars(t_1, \ldots, t_n), \dotx \neq \{ t_1, \ldots, t_n \sqcup \dotx \} \to t_1 \not\in \dotx \lor \ldots \lor t_n \not\in \dotx
		\end{equation}
		\begin{equation}
		\text{If} \dotx \in vars(t), \dotx \neq t \to true
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ t_1 \sqcup & A \} = \{ t_2 \sqcup B \} \to \\
		& N \in \{ t_1 \sqcup A \} \land N \not\in \{ t_2 \sqcup B \} \\
		& N \not\in \{ t_1 \sqcup A \} \land N \in \{ t_2 \sqcup B \}
		\end{split}
		\end{equation}
		\begin{equation}
		f(t_1, \ldots, t_n) \neq g(u_1, \ldots, u_m) \to true
		\end{equation}
		\begin{equation}
		f(t_1, \ldots, t_n) = f(u_1, \ldots, u_n) \to t_1 \neq u_1 \land \ldots \land t_1 \neq u_n
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di disuguaglianza}
	\label{fig:neq_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotx \neq t$ e $\dotx$ non compare ne in $t$ ne come
          argomento di qualunque predicato $p(\ldots)$, $p \in \{ un,
          id, inv, comp \}$.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:neq_constraints}

\subsection{Regole di riscrittura per vincoli (positivi) su insiemi}
\label{subsec:clpbasedlang_lset_rewriteset}

\subsubsection{Il vincolo in}

\textit{Sintassi:} $t_1 \in t_2$.\\
\noindent\textit{Semantica informale:} se $t_2$ è un insime, $t_1$ è un membro di $t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:in_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\in$\textsubscript{\arabic{equation}}}

		If $x, y: \text{U}; A: \text{Set}$ then:

		\begin{equation}
		x \in \emptyset \to false
		\end{equation}
		\begin{equation}
		x \in \{ y \sqcup A \} \to x = y \lor x \in A
		\end{equation}
		\begin{equation}
		x \in \dotA \to \dotA = \{ x \sqcup N \}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di appartenenza}
	\label{fig:in_constraints}
\end{figure}

\paragraph{Forme irriducibili} Nessuna.

\paragraph{Implementazione}
Algoritmo \ref{alg:in_constraints}

\subsubsection{Il vincolo union}

\textit{Sintassi:} $un(t_1, t_2, t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi,  allora $t_3 = t_1 \cup t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:un_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\cup$\textsubscript{\arabic{equation}}}

		If $t: \text{U}; A, B, C: \text{Set}$ then:

		\begin{equation}
		un(A,A,B) \to A = B
		\end{equation}
		\begin{equation}
		un(A,B,\emptyset) \to A = \emptyset \land B = \emptyset
		\end{equation}
		\begin{equation}
		un(\emptyset,A,\dotB) \to \dotB = A
		\end{equation}
		\begin{equation}
		un(A,\emptyset,\dotB) \to \dotB = A
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (\{ t \sqcup C \}, A, \dotB) \to \\
		& (t \not\in A \land un(N_1, A, N) \\
		& \lor A = \{ t_1 \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		& \land \{ t\sqcup C \} = \{ t \sqcup N_1 \} \land \dotB = \{ t\sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (A, \{ t \sqcup C \}, \dotB) \to \\
		& (t \not\in A \land un(N_1, A, N) \\
		& \lor A = \{ t_1 \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		& \land \{ t\sqcup C \} = \{ t \sqcup N_1 \} \land \dotB = \{ t\sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (A, B, \{ t \sqcup C \}) \to \\
		& (A = \{t \sqcup N_1 \} \land un(N_1, N_2, N) \\
		& \lor B = \{ t \sqcup N_1 \} \land un(A, N_1, N) \\
		& \lor A = \{ t \sqcup N_1 \} \land B = \{ t \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		& \land \{ t \sqcup C \} = \{ t \sqcup N \}
		\end{split}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di appartenenza}
	\label{fig:un_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $un(\dotA, \dotB, \dotC)$, $\dotA$ e $\dotB$ variabili distinte.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:un_constraints}

\subsubsection{Il vincolo disj}

\textit{Sintassi:} $t_1 \mid\mid t_2$.\\
\noindent\textit{Semantica informale:} se $t_1$ e $t_2$ sono insiemi, allora $t_1 \cap t_2 = \emptyset$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:disj_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\mid\mid$\textsubscript{\arabic{equation}}}

		If $t, t_i: \text{U}; A, B: \text{Set}$ then:

		\begin{equation}
		\emptyset \mid\mid A \to true
		\end{equation}
		\begin{equation}
		A \mid\mid \emptyset \to true
		\end{equation}
		\begin{equation}
		\dotA \mid\mid \dotA \to \dotA = \emptyset
		\end{equation}
		\begin{equation}
		\{ t \sqcup B \} \mid\mid \dotA \to t \not\in \dotA \land \dotA \mid\mid B
		\end{equation}
		\begin{equation}
		\dotA \mid\mid \{ t \sqcup B \} \to t \not\in \dotA \land \dotA \mid\mid B
		\end{equation}
		\begin{equation}
		\{ t_1 \sqcup A \} \mid\mid \{ t_2 \sqcup B \} \to t_1 \neq t_2 \land t_1 \not\in B \land t_2 \not\in A \land A \mid\mid B
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di disgiunzione}
	\label{fig:disj_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotA \mid\mid \dotB$, $\dotA$ e $\dotB$ variabili distinte.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:disj_constraints}

\subsubsection{Il vincolo subset}

\textit{Sintassi:} $t_1 \subseteq t_2$.\\
\noindent\textit{Semantica informale:} se $t_1$ e $t_2$ sono insiemi, allora $t_1$ è un sottoinsieme di $t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:subset_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{\textsubscript{\arabic{equation}}}

		If $x, y: \text{U}; A, B: \text{Set}$ then:

		\begin{equation}
		\dotA \subseteq \dotA \to true
		\end{equation}
		\begin{equation}
		\emptyset \subseteq A \to true
		\end{equation}
		\begin{equation}
		\dotA \subseteq \emptyset \to \dotA = \emptyset
		\end{equation}
		\begin{equation}
		\{ t \sqcup A \} \subseteq \emptyset \to false
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ x \sqcup A \} & \subseteq \dotB \to \\
		& \dotB = \{ x \sqcup N \} \land A \subseteq \{ x \sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ x \sqcup A \} & \subseteq \{ y \sqcup B \} \to \\
		& x = y \land A \subseteq \{ y \sqcup B \} \\
		& \lor x \neq y \land x \in B \land A \subseteq \{ x \sqcup B \}
		\end{split}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di sottoinsieme}
	\label{fig:subset_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotA \subseteq \dotB$, $\dotA$ e $\dotB$ variabili distinte;
	\item $\dotA \subseteq \{ y | B \}$.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:subset_constraints}

\subsubsection{Il vincolo inters}

\textit{Sintassi:} $inters(t_1,t_2,t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi, allora $t_3 = t_1 \cap t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:intersect_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{7}
		\renewcommand{\theequation}{$\cup$\textsubscript{\arabic{equation}}}

		If $x: \text{U}; A, B, C: \text{Set}$ then:

		\begin{equation}
		inters(\dotA, \dotA, B) \to A = B
		\end{equation}
		\begin{equation}
		inters(\emptyset, \dotA, C) \to C = \emptyset
		\end{equation}
		\begin{equation}
		inters(\dotA, \emptyset, C) \to C = \emptyset
		\end{equation}
		\begin{equation}
		inters(A,B,\emptyset) \to A \mid\mid B
		\end{equation}
		\begin{equation}
		\begin{split}
		inters & (A,B,\dotC) \to \\
		& A = \{ x \sqcup N_1 \} \\
		& \lor B = \{ x \sqcup N_2 \} \land \dotC = \{ x \sqcup N_3 \} \land inters(N_1, N_2, N_3)
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		inters & (A,B,\dotC) \to \\
		& A = \{ x \sqcup N_1 \} \land B = \{ x \sqcup N_2 \} \land inters(N_1, N_2, C)
		\end{split}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di intersezione}
	\label{fig:intersect_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $inters(\dotA, B, \dotC)$, $\dotA$ e $B$ non sono la stessa variabile;
	\item $inters(A, \dotB, \dotC)$, $A$ e $\dotB$ non sono la stessa variabile.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:inters_constraints}

\subsubsection{Il vincolo diff}

\textit{Sintassi:} $diff(t_1,t_2,t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi, allora $t_3 = t_1 \setminus t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:difference_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{\textsubscript{\arabic{equation}}}

		If $A, B, C: \text{Set}$ then:

		\begin{equation}
		diff(A,B,C) \to un(C,A,A) \land un(B,C,N) \land un(A,N,N)
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di differenza}
	\label{fig:difference_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item Nessuna.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:diff_constraints}

\subsection{Regole di riscrittura per vincoli negativi su insiemi}
\label{subsec:clpbasedlang_lset_rewriteneg}

I vincoli negativi su insiemi in \lset{} non sono dati dalla comune
negazione, bensì sono introdotti come vincoli derivati. La negazione
classica viene eliminata e per ogni predicato $\neg p(t_1, \ldots,
t_n)$ si ottiene una forma positiva del predicato $p'(t_1, \ldots,
t_n)$ che ne rappresenta la negazione.

\subsubsection{Il vincolo not in}

\textit{Sintassi:} $t_1 \not\in t_2$.\\
\noindent\textit{Semantica informale:} se $t_2$ è un insieme, allora $t_1$ non è un membro di $t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:notin_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{3}
		\renewcommand{\theequation}{$\in$\textsubscript{\arabic{equation}}}

		If $x, y: \text{U}; A, B, C: \text{Set}$ then:

		\begin{equation}
		x \not\in \emptyset \to true
		\end{equation}
		\begin{equation}
		x \not\in \{ y \sqcup A \} \to x \neq y \land x \not\in A
		\end{equation}
		\begin{equation}
		\text{If } \dotA \in vars(x), x \not\in \dotA \to true
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di non appartenenza}
	\label{fig:notin_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $t \not\in dotA$, e $dotA$ non occorre in $t$.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:notin_constraints}

\subsubsection{Il vincolo not union}

\textit{Sintassi:} $nun(t_1,t_2,t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi, allora $t_3 \neq t_1 \cup t_2$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:notun_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{13}
		\renewcommand{\theequation}{$\cup$\textsubscript{\arabic{equation}}}

		If $A, B, C: \text{Set}$ then:

		\begin{equation}
		\begin{split}
		nun(& A,B,C) \to \\
		  & N \in C \land N \not\in A N \not\in B \\
		  & \lor N \in A \land N \not\in C \\
		  & \lor N \in B \land N \not\in C
		\end{split}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli non unione}
	\label{fig:notun_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item Nessuna.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:notun_constraints}

\subsubsection{Il vincolo not disjoint}

\textit{Sintassi:} $t_1 \not\mid\mid t_2$.\\
\noindent\textit{Semantica informale:} se $t_1$ e $t_2$ sono insiemi, allora $t_1 \cap t_2 \neq \emptyset$.\\
\noindent\textit{Regole di riscrittura:} Figura \ref{fig:notdisj_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{6}
		\renewcommand{\theequation}{$\mid\mid$\textsubscript{\arabic{equation}}}

		If $A, B: \text{Set}$ then:

		\begin{equation}
		A \not\mid\mid B \to N \in A \land N \in B
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per vincoli di non disgiunzione}
	\label{fig:notdisj_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item Nessuna.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:notdisj_constraints}

\subsubsection{Altri vincoli negativi}

\noindent\textit{Regole di riscrittura:} Figura \ref{fig:othernegatives_constraints}.

\begin{figure}
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{\arabic{equation}}

		If $R, S, T, A, B, C: \text{Set}$ then:

		\begin{equation}
		nsubset(A,B) \to n \in A \land n \not\in B
		\end{equation}
		\begin{equation}
		\begin{split}
		ninters& (A,B,C) \to \\
		  & n \in C \land ( n \not\in A \lor n \in C \land n \not\in B ) \\
		  & \lor n \not\in C \land n \in A \land n \not\in B
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		ndiff& (A,B,C) \to \\
		  & n \in C \land n \not\in A \lor n \in C \land n \in B \\
		  & \lor n \not\in C \land n \in A \land n \not\in B
		\end{split}
		\end{equation}

	\end{tcolorbox}

	\caption{Regole di riscrittura per altri vincoli negativi}
	\label{fig:othernegatives_constraints}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item Nessuna.
\end{itemize}

\paragraph{Implementazione}
Algoritmo \ref{alg:othernegatives_constraints}



%%% *******************************************************
%%% Picat
\chapter{Picat}
\label{ch:picat}

\minitoc

In questo capitolo viene presentato Picat, un linguaggio di
programmazione multiparadigma basato sulla logica dei predicati del
prim'ordine. Picat è per certi versi molto simile al Prolog, ma
dispone di molte funzionalità che modificano radicalmente l'utilizzo
comune sia di un linguaggio imperativo che logico.

Nella sezione \ref{sec:picat_features} si descrivono le carateristiche
di Picat, mentre in \ref{sec:picat_base} e \ref{sec:picat_advanced} se
ne espongono le funzionalità fornendo esempi esplicativi.

I numerosi dettagli tralasciati per ovvi motivi in questa
presentazione possono essere approfonditi sul manuale di Picat
\cite{PicatGuide}. Si avvisa inoltre che al tempo in cui si sta
scrivendo, la guida di Picat è in versione 2.6.

\section{Caratteristiche}
\label{sec:picat_features}

Picat incorpora le principali funzionalità dei linguaggi logici,
funzionali e di scripting. Le caratteristiche di Picat sono riassunte
dalle lettere del suo nome:
\begin{itemize}
\item \textbf{P}attern-matching. Un \emph{predicato} definisce una relazione e può avere zero, una o più soluzioni. Picat è un linguaggio basato su regole. I predicati e le funzioni sono definiti tramite regole di pattern-matching.
\item \textbf{I}ntuitive. Picat fornisce comandi come l'assegnamento ed i loop, che vengono usati nei comuni linguaggi imperativi, rendendolo di fatto più affine per la scrittura di programmi "comuni".
\item \textbf{C}onstraints. Picat supporta la programmazione con vincoli. Nasce infatti con quattro moduli per la risoluzione di vincoli: \verb|cp|, \verb|sat|, \verb|smt| e \verb|mip|.
\item \textbf{A}ctors. Viene fornito il supporto a chiamate event-driven tramite \emph{action rules}, utilizzate per descrivere il comportamento degli attori event-driven.
\item \textbf{T}abling. Il tabling è utilizzato per memorizzare la soluzione di un calcolo in memoria, permettendo quindi una rapida consultazione del risultato senza ricalcolo. Per questo motivo, il modulo \verb|planner| di Picat ne fa largo uso. 
\end{itemize}

Inoltre, Picat supporta le principali caratteristiche dei linguaggi logici, obbligando però il programmatore ad usarle in modo esplicito, come per il caso dell'unificazione, del non determinismo, del tabling e dei vincoli.

\section{Funzionalità di base}
\label{sec:picat_base}

\subsection{Il sistema Picat}
\label{sec:picat_base_system}

Picat è un linguaggio interpretato. I programmi Picat però, prima di essere eseguiti, sono compilati. Il compilatore non trasforma i sorgenti in codice macchina, ma depura il programma da tutto quello che non è necessario per l'esecuzione, esegue alcuni controlli statici e riscrive alcuni costrutti sintatticamente (e.g. i cicli).

Tramite l'interprete Picat è possibile caricare, compilare ed eseguire programmi, possibilmente anche modalità debug.

\paragraph{Esempio}\
\begin{verbatim}
> picat
Picat> compile(program)
Picat> load(program)
Picat> main.
\end{verbatim}

\subsection{Tipi di dato}
\label{sec:picat_base_datatype}

Picat è un linguaggio tipato dinamicamente: il controllo dei tipi avviene a runtime. Le variabili in Picat possono avere o non avere un valore. Una variabile è libera fintanto che non viene vincolata ad un valore (operazione di bounding), e può avere degli attributi rappresentati come mappa chiave-valore.

I tipi primitivi di Picat sono il numero intero, reale e l'atomo. Un atomo è un nome iniziante con lettera miniscola o una stringa quotata da apici singoli.

I tipi composti invece sono le liste \verb|[|$t_1, \ldots, t_n$\verb|]| e le strutture \verb|$s(|$t_1, \ldots, t_n$\verb|)|, dove $s$ è il nome della struct, ed $n$ è l'arità. Il dollaro viene impiegato per distinguere una chiamata di funzione da una struct. Picat inoltre mette a disposizione tipi composti speciali come \emph{strings}, \emph{arrays}, \emph{maps}, \emph{sets} e \emph{heaps}.

\paragraph{Esempio}\
\begin{verbatim}
Picat> V1 = X1, V2 = _ab, V3 = _       % variabili

Picat> N1 = 12, N2 = 0xf3, N3 = 1.0e8  % numeri

Picat> A1 = x1, A2 = ’_AB’, A3 = ''    % atomi

Picat> L = [a,b,c,d]                   % liste

Picat> write("hello"++"picat")
[h,e,l,l,o,p,i,c,a,t]                  % stringhe

Picat> print("hello"++"picat")
hellopicat

Picat> writef("%s","hello"++"picat")
hellopicat                             % write con formato

Picat> writef("%-5d %5.2f",2,2.0)
2
2.00                                   % write con formato

Picat> S = $point(1.0,2.0)             % struttura

Picat> S = new_struct(point,3)
S = point(_3b0,_3b4,_3b8)              % creazione di una struttura

Picat> A = {a,b,c,d}                   % array

Picat> A = new_array(3)
A = {_3b0,_3b4,_3b8}                   % creazione di un array

Picat> M = new_map([one=1,two=2])
M = (map)[two = 2,one = 1]             % creazione di una map

Picat> M = new_set([one,two,three])
M = (map)[two,one,three]               % creazione di un insieme

Picat> X = 1..2..10
X = [1,3,5,7,9]                        % ranges

Picat> X = 1..5
X = [1,2,3,4,5]
\end{verbatim}

Picat possiede una ricca libreria di funzioni di utilità sui tipi di dato che permettono, tra le altre cose, di verificare qual è il tipo di una variabile, convertire tipi ad altri tipi e aggiungere elementi ad un insieme.

\subsection{Predicati}
\label{sec:picat_base_pred}

I predicati sono una componente fondamentale di Picat. Un predicato ha esito positivo o negativo, a meno di eccezioni. Un predicato può esplorare tutte le soluzioni tramite il backtracking implementato in Picat.

In Picat i predicati sono definiti con regole di pattern-matching. Le regole utilizzabili per la definizione di un predicato sono $Head, Cond => Body$ e $Head, Cond\ ?=> Body$ che rappresentano rispettivamente la regola \emph{non-backtrackable} e \emph{backtrackable}. La testa $Head$ del predicato è $p(t_1, \ldots, t_n)$ con $p$ il nome del predicato e $n$ l'arità. Le condizioni $Cond$ sono goal opzionali che specificano l'applicabilità della regola. $Body$ è li corpo del predicato.
Quando una chiamata $C$ è applicabile, Picat riscrive $C$ in $Body$. Se la regola usata è \emph{non-backtrackable} allora la riscrittura è permanente, altrimenti il programma farà backtracking su $C$ se $Body$ fallisce e verrà provata la regola successiva.



\paragraph{Esempio} Regola non backtrackable.
\begin{verbatim}
membchk(X,[X|_]) => true.
membchk(X,[_|L]) => membchk(X,L)

Picat> membchk(X,[1,2,3]).
no
\end{verbatim}

\paragraph{Esempio} Regola backtrackable.
\begin{verbatim}
member(X,[Y|_]) ?=> X=Y.
member(X,[_|L]) => member(X,L).

Picat> member(X,[1,2,3])
X = 1;
X = 2;
X = 3;
no
\end{verbatim}

\subsection{Funzioni}
\label{sec:picat_base_func}

Picat permette di definire delle funzioni, ovvero oggetti che hanno sempre esito positivo e che ritornano un solo valore. La sintassi di una funzione è $Head, Cond = Result => Body$. Le funzioni in picat sono uno zucchero sintattico per un predicato cos' formato: $HeadResult, Cond => Body$ dove $HeadResult = p(t_1, \ldots, t_n, r)$.

\paragraph{Esempio}
\begin{verbatim}
fib(0)=F => F=1.
fib(1)=F => F=1.
fib(N)=F,N>1 => F=fib(N-1)+fib(N-2).

Picat> X = fib(8) 
X = 21
yes
\end{verbatim}

\subsection{Assegnamenti e Cicli}
\label{sec:picat_base_asscycle}

Picat cerca di agevolare notevolmente i programmatori affini a linguaggi imperativi. Per questo motivo offre funzionalità come l'assegnamento, tipicamente non disponibile in un linguaggio logico,
e cicli, che nei linguaggi logici si realizzano con la ricorsione.

\subsubsection{Assegnamento}

Anche l'assegnamento, come altri comandi, è uno zucchero sintattico. Un assegnamento in Picat $X := Y$ viene gestito a tempo di compilazione creando nuovi nomi di variabile. Le nuove variabili conterranno il nuovo valore dopo l'assegnamento e verranno usati nella porzione di programma successiva all'assegnamento al posto della vecchia variabile.

\paragraph{Esempio}
\begin{verbatim}
test => X=0, X:=X+1, X:=X+1, write(X).
\end{verbatim}
ha come output $2$, e con la compilazione viene riscritto in
\begin{verbatim}
test => X=0, X1=X+1, X2=X1+1, write(X2).
\end{verbatim}
avente anch'esso output $2$.

\subsubsection{Cicli}

Picat supporta tre tipo di cicli: \verb|foreach|, \verb|while| e \verb|do-while|. Il \verb|foreach| viene usato per implementare un particolare tipo di ciclo su liste denominato \emph{list comprehension}.

\paragraph{Esempio}\
\begin{lstlisting}
% esempio di foreach
L = [2, 3, 5, 10],
foreach(I in L, J in 1 .. 10, J mod I != 0)
	printf("%d is not a multiple of %d%n", J, I)
end.

% esempio di while
I = 1,
while (I <= 9)
	println(I),
	I := I + 2
end.

% esempio di do while
J = 6,
do
	println(J),
	J := J + 1
while (J <= 5).
\end{lstlisting}

Mentre per i tipi di cicli più comuni la semantica è piuttosto ovvia, per le list comprehension la cosa è più interessante. Le list comprehension sono funzioni che servono a costruire una lista iterando valori di altre liste.

La list comprehension ha la seguente sintassi
\begin{lstlisting}
[T : $E_1$ in $D_1$, $Cond_1$ , $\ldots$, $E_n$ in $D_n$ , $Cond_n$]
\end{lstlisting}

\paragraph{Esempio}\
\begin{lstlisting}
picat> L = [(A, I) : A in [a, b], I in 1 .. 2].
L = [(a , 1),(a , 2),(b , 1),(b , 2)]
\end{lstlisting}

\section{Funzionalità avanzate}
\label{sec:picat_advanced}

In questa sezione si da una panoramica delle funzionalità avanzate in Picat. Anche in questo caso si raccomanda al lettore l'approfondimento dei dettagli in \cite{PicatGuide}.

\subsection{Tabling}
\label{sec:picat_advanced_tabling}

Il tabling è un meccanismo di caching che permette di memorizzare la chiamata ad un predicato e relativo risultato per evitare cicli infiniti o per ridurre il costo computazione dovuto alla grossa ridondanza dei calcoli.

\paragraph{Esempio}\
\begin{lstlisting}
table
fib(0) = 1.
fib(1) = 1.
fib(N) = fib(N-1)+fib(N-2).
\end{lstlisting}
Senza tabling \verb|fib(N)| ha costo esponenziale in \verb|N|, con il tabling invece il costo è lineare.

Il tabling è abilitato usando la keyword \verb|table| prima della definizione del predicato.

\subsection{Moduli}
\label{sec:picat_advanced_modules}

I moduli sono una funzionalità molto utile di Picat e permettono al programmatore un'organizzazione comoda del codice sorgente, suddivisa su più file (moduli, appunto).

Un modulo è un file sorgente con estensione \verb|.pi|. Un modulo inizia con la dichiarazione di se stesso nella forma \verb|module| $Name$, dove $Name$ corrisponde al nome del file.

Picat fornisce un sistema molto semplice di import, consentendo così di accedere a funzionalità di altri file sorgente. La sintassi per l'import è 
\begin{lstlisting}
import $Name_1, \ldots, Name_n$.
\end{lstlisting}

E' possibile chiamare predicati di un modulo specificando completamente il nome del predicato con \verb|m.p()|, dove \verb|m| è il nome del modulo e \verb|p| è il nome del predicato. E' consentito proibire l'utilizzo di un predicato da moduli esterni appondendo la keyword \verb|private| prima della definizione del predicato.

\subsection{Eccezioni}
\label{sec:picat_advanced_exceptions}

Picat fornisce un semplice sistema di gestione delle eccezioni, con cui è possibile gestire eventi eccezionali ed errori non previsti.

La sintassi per il lancio delle eccezioni è 
\begin{lstlisting}
throw Exception
\end{lstlisting}
mentre la cattura e la gestione dell'eccezione si effettua tramite
\begin{lstlisting}
catch(Goal, Exception, Handler)
\end{lstlisting}

\subsection{Higher-Order Calls}
\label{sec:picat_advanced_hoc}

Un predicato o una funzione è di ordine superiore se riceve funzioni come argomenti. Alcuni predicati di ordine superiore \emph{built-in} del linguaggio sono \verb|call|, \verb|apply| e \verb|find_all|. I predicati \verb|call| e \verb|apply| prendono in input un nome di funzione e lo eseguono con gli argomenti dati; \verb|apply| può ritornare un valore. Il predicato \verb|find_all| invece trova tutte le soluzioni della chiamata per la funzione in input.

Picat fornisce altri predicati di ordine superiore per la gestione delle eccezioni, l'esecuzione e alte utilità.

\paragraph{Esempio}
\begin{verbatim}
Picat> S=$member(X), call(S,[1,2,3])
X = 1;
X = 2;
X = 3;
no

Picat> L=findall(X,member(X,[1,2,3])).
L = [1,2,3]

Picat> Z=apply(’+’,1,2)
Z = 3
\end{verbatim}

\subsection{Action Rules}
\label{sec:picat_advanced_actionrules}

Picat fornisce \emph{Action Rules} per descrivere attori event-driven. Un attore è un chiamata ad un predicato che può essere differita rispetto alla normale esecuzione ed è attivabile da eventi. Queste regole hanno sintassi $Head, Cond, \{Event\} => Body$, dove $Event$ è un insieme non vuoto di eventi separati da virgola.

Gli attori possono essere assegnati a canali sui quali sono notificati gli eventi. Un canale è una variabile con degli attributi in grado di notificare eventi. Un canale può avere diverse porte, che specificano la visiblità dell'evento per qel canale. 

\subsection{Mappe Globali}
\label{sec:picat_advanced_globalmaps}

Picat fornisce tre tipi diversi di mappe globali utilizzabili durante l'esecuzione: mappe \emph{heap}, mappe \emph{globali} e \emph{tabelle}.

Queste mappe sono create non appena il sistema Picat si avvia. Possono essere consultate richiedendo a Picat una mappa e fornendo un \emph{ID} per la stessa. Le tre mappe differiscono per la modaltà di memorizzazione degli elementi e per il numero di mappe che possono essere richieste.

Queste mappe sono accessibili durante tutta l'esecuzione e sono quindi molto utili per memorizzare variabili globali.

\section{Picat vs. Prolog}
\label{sec:picat_picatvsprolog}

Sebbene Picat sia un linguaggio multi paradigma, esso è profondamente legato ai concetti di programmazione logica includendo \emph{variabili logiche}, \emph{unificazione} e \emph{backtracking}.
Come in Prolog, le variabili di Picat sono etichette a valori. Una variabile logica può essere legata a qualunque termine, includendo altre variabili logiche (una volta sola).

\begin{description}
\item[Unificazione e pattern-matching.] L'unificazione è l'operazione di base sia in Picat che in Prolog per effettuare il bound delle variabili a termini. Ma mentre in Prolog l'unificazione viene utilizzata anche nella risoluzione delle regole, in Picat viene impiegato il pattern-matching per dicidere se una regola è applicabile o meno. Ciò comporta alcune divergenze tra l'esecuzione della stessa regola in Prolog e in Picat.
Inoltre, l'operazione di pattern-matching sulle regole è molto più leggera rispetto all'unificazione.
\item[Backtracking.] Anche Picat supporta nativamente il backtracking. In Prolog però ogni regola è implicitamente \emph{backtrackable} e si usa l'operatore \emph{cut} \verb|!| per controllarne il comportamento. In Picat invece una regola è \emph{backtrackable} solo se esplicitamente dichiarato. Ciò permete al programmatore di capire a colpo d'occhio l'intenzione di una regola.
\item[Predicati dinamici.] Picat non supporta i predicati dinamici, mentre in Prolog è possibile asserire un predicato durante l'esecuzione, dando di fatto più flessibilità al linguaggio.
\item[Operatori definiti da utente.] In Picat non è possibile definire nessun operatore, mentre in Prolog è possibile estendere il set di operatore aggiungendone di nuovi.
\item[Costrutti.] Una delle differenze più evidenti tra i due linguaggi sono i costrutti. Picat infatti fornisce molti costrutti per svolgere operazioni comuni quali assegnamenti, cicli e salti condizionali. Non mancano inoltre un buon numero di tipi di dato predefiniti con relative operazioni, che per attività di scripting e modellazione rendono Picat più conveniente rispetto al Prolog.
\end{description}


%%% *******************************************************
%%% Solver CLP(SET) in Picat
\chapter{\lset{} in Picat}
\label{ch:lsetpicat}

\minitoc

L'obiettivo principale del solver \lset{} è risolvere formule. Il risultato può avere zero, una o più soluzioni ed il solver deve essere in grado di mostrarle tutte, se queste sono finite.

Il funzionamento del solver è quello descritto dallo pseudocodice in  \ref{subsec:lang_lset_solver}. Per ricapitolare, il solver svolge queste tre azioni:
\begin{itemize}
\item rimpiazza i vincoli derivati con le corrispondenti formule \lset{};
\item riduce la complessità sintattica dei vincoli primitivi applicando le regole di riscrittura corrette;
\item elimina gli insiemi che coinvolgono disuguaglianze.
\end{itemize} 
La formula finale ottenuta è semplificata e irriducibile, il che la rende equivalente alla formula originale.

Nella sezione \ref{sec:lsetpicat_system} si fornisce una descrizione del sistema dal punto di vista generale, includendo l'ingegnerizzazione e la suddivisione in moduli delle funzionalità, nonché il testing. Nella sezione \ref{sec:lsetpicat_solver} viene approfondito il solver, il suo funzionamento ed i predicati implementati.

\section{Organizzazione del progetto}

\begin{verbatim}
.
|-- JOURNAL.txt
|-- LICENSE.txt
|-- Makefile
|-- README.md
|-- src
|   |-- assert.pi
|   |-- commands.pi
|   |-- global.pi
|   |-- log_h.pi
|   |-- lset.pi
|   |-- main.pi
|   |-- Makefile
|   |-- prompt.pi
|   `-- solver.pi
`-- tests
    |-- lset_test.pi
    |-- Makefile
    `-- solver_test.pi
\end{verbatim}

\begin{itemize}
	\item \verb|JOURNAL.txt|, il diario di bordo. Vi sono note ed evoluzione del progetto in linea temporale.
	\item \verb|LICENSE.txt|, la licenza del codice sorgente.
	\item \verb|README.md|, la descrizione del progetto contenente note per l'installazione e l'utilizzo.
	\item \verb|Makefile|,\fixme{Da finire}
	\item \verb|src|, la cartella contenente i file sorgenti. I moduli che compongono il sistema sono mostrati in \ref{sec:lsetpicat_system}.
	\item \verb|tests|, la cartella contenente i test dei componenti fondamentali.
\end{itemize}

\section{Il sistema}
\label{sec:lsetpicat_system}

\subsection{Interprete}
\label{sec:lsetpicat_system_interpreter}

L'interprete realizzato per la gestione del sistema nel suo insieme è suddiviso per funzionalità: grazie alle caratteristiche di Picat queste funzionalità sono state raggruppate e separate in \emph{moduli} (vedere \ref{sec:picat_advanced_modules} per ulteriori informazioni sul modulo). Ognuno di questi moduli cerca di essere il più coeso possibile e fornisce funzionalità ad altri moduli, incrementando quindi la riusabilità del codice.

I moduli identificati e realizzati sono descritti nel seguito.

\subsubsection{solver.pi}

\verb|solver|. \'E il modulo principale che realizza la risoluzione delle formule. Espone il predicato \verb|solve/2|, utilizzabile da qualunque programma Picat per risolvere una formula di \lset{}. Questo modulo viene ampiamente trattato in \ref{sec:lsetpicat_solver}.

\subsubsection{lset.pi}

\verb|lset|. Contiene l'interfaccia e l'implementazione degli insiemi nei termini di \lset{}. Consente di astrarre l'entità insieme dalla sua implementazione reale. L'approccio OOP è intenzionale: Picat, come detto in precedenza, favorisce la programmazione imperativa e la ricalca con costrutti e funzioni molto simili dal punto di vista logico.

\paragraph{Costruttore}
\begin{verbatim}
new_lset() = [].
new_lset(ListRest) = Lset => 
    if (not list(ListRest)) 
    then Lset = [ListRest]
    else Lset = ListRest
    end.
new_lset(Head, Rest) = Lset =>
    if (not list(Head)) then Head := [Head] end,
    append(Head, Rest, Lset).
\end{verbatim}

\paragraph{Metodi}
\begin{verbatim}
%% lset_rest(lset(X)) = R
%
% @param lset(X)  The lset from which take the rest.
% @return  The rest (with setlog meaning) R from lset(X).

lset_rest(X) = R => lset_rest(X, R).

%% lset_head(lset(X)) = R
%
% @param lset(X)  The lset from which take the head.
% @return  The head (with setlog meaning) R from lset(X).

lset_head(X) = R => lset_head(X, R).
\end{verbatim}
In \verb|lset_rest/2| e \verb|lset_head/2| risiede l'implementazione (privata) delle due funzionalità.

\subsubsection{commands.pi}

\verb|commands|. Gestisce l'interfaccia utente. E' una CLI orientata all'usabilità utente: fornisce messaggi di aiuto, cerca di effettuare controlli sull'input e una sapiente gestione degli errori.

\begin{verbatim}
%% obeyCommands() is det
% 
% @desc Realizes the cycle of interaction with the user:
%  commands are read, their legality is checked and,
%  if they are correct, they are executed.

obeyCommands() ?=>
    while(true)
        readCommandLine([Command | Arguments]),
        if membchk(Command, getKnownCommands()) then
            doCommand(Command, Arguments),
            if not membchk(Command, getNoHistoryCommands()) then
                pushLastCommand(Command, Arguments)    
            end
        else 
            unknownCommand(Command)
        end
    end.
obeyCommands() => obeyCommands().

...

%% doSolve(+FormulaString) is det
%
% @desc Issue the solver with the given formula and allow to show
%  all solutions.

doSolve(FormulaString) ?=>
    parse_term(FormulaString, Term, Vars),
    solve(Term, Res),
    println("Vars: " ++ Vars.to_string),
    println("Constraints: " ++ Res.to_string),
    nl,
    A = confirm("Another solution?"),
    if A == 1 then fail end.
doSolve(_) => println("no!").
\end{verbatim}

\subsubsection{global.pi}

\verb|global|. Gestiosce le variabili globali. Aiuta il programmatore ad effettuare operazioni sulle variabili globali senza conoscere il tipo di mappa globale utilizzata e senza effettuare manipolazione di mappe direttamente.

\begin{verbatim}
%% get_global(+Key) = Value
%
% @desc Get variable with name Key and return it's value in Value.
get_global(Key) = Value =>
    G = get_map(),
    Value = G.get(Key).

%% set_global(+Key, +Value)
%
% @desc Set a variable with name Key and value Value.
set_global(Key, Value) =>
    G = get_map(),
    G.put(Key, Value).
\end{verbatim}

\subsubsection{log\textunderscore h.pi}

\verb|log_h|. Gestisce i log con diverse modalità di verbosità e tipo di messaggi.

\begin{verbatim}
log_d(X) => println(get_log_file_fd(), "D: " ++ X.to_string).
log_e(X) => println(get_log_file_fd(), "E: " ++ X.to_string).
log_i(X) => println(get_log_file_fd(), "I: " ++ X.to_string).

log_d_v(X)   => log_d(X, v).
log_d_vv(X)  => log_d(X, vv).
log_d_vvv(X) => log_d(X, vvv).

log_d(X, V), membchk(V, log_mode()) => log_d(X).
log_d(X, V), membchk(all, log_mode()) => log_d(X).
log_d(X, V) => true.
\end{verbatim}

\subsubsection{prompt.pi}

\verb|prompt|. Crea un livello di astrazione sopra l'I/O generico, permettendo quindi una gestione più fine dell'input e dell'output per esempio con formattazione e stampe condizionali.

\begin{verbatim}
%% echo(P) is det
%
% @desc Print the phrase P to the standard output if echo is 
%  enabled (i.e., the global prompt_echo_enabled is true).

echo(P), 
        is_global(quiet_mode), 
        get_global(quiet_mode) !== true  => 
    println(P.to_string).
echo(_) => true.  % Do nothing if disabled.
\end{verbatim}

\subsubsection{assert.pi}

\verb|assert|. Implementa metodi di utilità per la gestione degli \emph{unit tests}.

\begin{verbatim}
%% assert_equal(A, Expected, Actual)
%
% @param A:struct  The assertion object.
% @param Expected:atom  The expected value.
% @param Actual:atom    The actual value.
%
% @desc Log a success if Expected is identical to Actual, log a fail otherwise.

assert_equal(A, Expected, Actual), Expected == Actual => 
    log_i("SUCCESS " ++ ...").
assert_equal(A, Expected, Actual) => 
    log_e("FAILED "  ++ ...).
\end{verbatim}

\subsection{Testing}
\label{sec:lsetpicat_system_tests}

La stesura dei test per verificare la correttezza dell'implementazione si è subito resa necessaria al fine di incrementare la qualità del software prodotto. Per questo motivo sono stati realizzati predicati che prendono in esame casi semplici ma cercano di esploare i casi limite.

I test realizzati fanno uso del modulo \verb|assert| che mette a disposizione metodi di utilità come \verb|assert_equal/2|, \verb|assert_fail/1|, \verb|fail/1|. Grazie a questi predicati è possibile effettuare test con la seguente struttura
\begin{verbatim}
test1 ?=>
   A = new_assert(test1)
   solve(Formula, Result),
   A.assert_equal([], Result)
test1 => 
   A = new_assert(test1), A.fail().
\end{verbatim}
dove \verb|assert_equal/2| verifica che il valore attuale sia uguale al valore previsto, e se non lo è fallisce attivando il predicato \verb|fail/1| che registra il fallimento di quel test.

\section{Il solver}
\label{sec:lsetpicat_solver}

\subsection{Predicato solve/2}
\label{sec:lsetpicat_solver_solve2}

Il predicato \verb|solve/2| riceve in input una formula, e restituisce in output la formula risolta. Questo predicato scandisce ogni termine della formula congiuntiva data in input e cerca di ridurla generando una nuova formula (possibilmente nulla) e un insieme di vincoli (possibilmente vuoto).

\paragraph{Implementazione} Il predicato \verb|solve/2| risolve la formula congiuntiva in input $C$ e riscrive ogni termine in forma più semplice, creando un nuovo constraint store $CN$. Se le riscritture applicate rendono il constraint store uguale alla formula in input allora si è raggiunto un \textbf{punto fisso} e si termina l'esecuzione con risultato $CC = CN$, altrimenti si prosegue cercando di risolvere il nuovo constraint store $solve(CN, CC)$.
\begin{verbatim}
%% solve(C, CC) is det

solve(C, CC) =>
    CN = [],
    foreach (T in C)
        sat(T, C1), 
        CN := CN ++ C1,
    end,
    CN := CN.flatten(),
   
    if C == CN 
    then CC = CN 
    else solve(CN, CC)
    end.
\end{verbatim}

\paragraph{Utilizzo} Il predicato \verb|solve/2| può essere usato come un API, esposta dal modulo \emph{solver}. Il modulo \emph{commands} di fatto usa questo predicato per risolvere una formula.
\begin{verbatim}
%% doSolve(+FormulaString) is semidet

doSolve(FormulaString) ?=>
    parse_term(FormulaString, Term, Vars),
    solve(Term, Res),
    println("Vars: " ++ Vars.to_string),
    println("Constraints: " ++ Res.to_string).
    nl,
    A = confirm("Another solution?"),
    if A == 1 then fail end.
doSolve(_) => println("no!").
\end{verbatim}

Il predicato \verb|solve/2| visto come API è utile anche nell'effetuare gli \emph{unit tests}. L'esempio riportato, seppur poco interessante dal punto di vista della formula, mostra l'utilizzo di \verb|solve/2| per verificare la correttezza della risoluzione.
\begin{verbatim}
setlog_eq1_1_test ?=>
    A = new_assert("setlog_eq1_1_test"),
    F = [$eq(1, 1)],
    solve(F, FF),
    A.assert_equal([], FF).
setlog_eq1_1_test => A = new_assert("setlog_eq1_1_test"), A.fail().
\end{verbatim}

\subsection{Predicato sat/2}
\label{sec:lsetpicat_solver_sat2}

Il predicato \verb|sat/2| combinato con \verb|rule/2| seleziona la regola da applicare in base al termine dato, distinguendo se l'operazione che si vuole compiere è $=, \neq, \in, \ldots$, e applicando le giuste regole di riscrittura. 

\paragraph{Implementazione} \verb|sat/2| gestisce l'input, mentre \verb|rule/2| effettua il dispatching della regola giusta. Notare come il predicato \verb|rule/2| sia pensato per essere estendibile.
\begin{verbatim}
%% sat(F, FF) is det

sat(F, FF), F == [] => FR = [].
sat(F, FF) => rule(F, FF).


%% rule(F, R) is det

rule(eq(T1, T2), R)  => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(or(T1, T2), R)  => or(T1, T2, R).
rule(or(T), R)       => or(T, R).
rule(insl(X, S), R)  => insl(X, S, R).
rule(nin(X, S), R)   => nin(X, S, R).
rule(contains(S, X), R)    => contains(S, X, R).
rule(union(S1, S2, S3), R) => union(S1, S2, S3, R).
rule(disj(S1, S2), R)      => disj(S1, S2, R).
rule(subset(S1, S2), R)    => subset(S1, S2, R).
\end{verbatim}

Le regole implementate sono un sottoinsieme di quelle descritte in \cite{Rossi18}.

\subsection{Vincoli integrati}
\label{sec:lsetpicat_solver_rewriterules}

Nel modulo \emph{solver}, oltre ai predicati descritti in precedenza e a qualche predicato ausiliario, sono presenti i predicati che implementano le regole di riscrittura:
\begin{itemize}
\item \verb|eq/3| ($=$);
\item \verb|neq/3| ($\neq$)
\item \verb|insl/3| ($\in$)
\item \verb|contains/3| ($contains$);
\item \verb|union/3| ($\cup$);
\item \verb|disj/3| ($||$);
\item \verb|subset/3| ($\subset$);
\item \verb|inters/3| ($\cap$);
\item \verb|diff/3| ($\setminus$);
\end{itemize}

Nella sezione \ref{sec:lsetpicat_constraints} sono riportate le regole di riscrittura e relative implementazioni. Si può notare che la descrizione matematica delle regole in \cite{Rossi18} è molto vicina all'implementazione.

\clearpage

\section{Regole di riscrittura}

\subsection{Il vincolo eq}

\textit{Sintassi:} $t_1 = t_2$.\\
\noindent\textit{Semantica informale:} $t_1$ e $t_2$ sono uguali.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:eq_constraints}.

\begin{figure}[H]
\label{fig:eq_constraints}

\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
\setcounter{equation}{0}
\renewcommand{\theequation}{=\textsubscript{\arabic{equation}}}

If $x, y, t, t_i, u_i: \text{U}; A,B: \text{Set}$ then:

\begin{equation}
\dotx = \dotx \to true
\end{equation}
\begin{equation}
\text{If } t \not\in \calV, t = \dotx \to \\ \dotx = t
\end{equation}
\begin{equation}
\text{If} \dotA \not\in vars(t_1, \ldots, t_n), \dotA = \{ t_1, \ldots, t_n \} \to \dotA = \{ t_1, \ldots, t_n \sqcup N \}
\end{equation}
\begin{equation}
\text{If} \dotx \in vars(t), \dotx = t \to false
\end{equation}
\begin{equation}
\dotx = t \to \text{substitute $\dotx$ by $t$ in all others literals of the input formula}
\end{equation}
\begin{equation}
\text{If} f \not\equiv g, f(t_1, \ldots, t_n) = g(t_1, \ldots, t_m) \to false
\end{equation}
\begin{equation}
\begin{split}
\{ t_1, & \ldots, t_m \sqcup \dotA \} = \{u_1, \ldots, u_n \sqcup \dotA \} \to \\
& t_1 = u_j \land \{ t_2, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots, u_{j_1}, u_{j+1}, \ldots, u_n \sqcup \dotA \} \\
& \lor t_1 = u_j \land \{ t_1, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots, u_{j_1}, u_{j+1}, \ldots, u_n \sqcup \dotA \} \\
& \lor t_1 = u_j \land \{ t_2, \ldots, t_m \sqcup \dotA \} = \{ u_1, \ldots u_n \sqcup \dotA \} \\
& \lor \dotA = \{ t_1 \sqcup N \} \land \{ t_2, \ldots, t_m \sqcup N \} = \{ u_1, \ldots, u_n \sqcup N \}
\end{split}
\end{equation}
\begin{equation}
\begin{split}
\{ x \sqcup & A \} = \{ y \sqcup B \} \to \\
& x = y \land A = B \\
& \lor x = y \land \{ x \sqcup A \} = B \\
& \lor x = y \land A = \{ y \sqcup B \} \\
& \lor A = \{ y \sqcup N \} \land \{ x \sqcup N \} = B
\end{split}
\end{equation}
\begin{equation}
f(t_1, \ldots, t_n) = f(u_1, \ldots, u_n) \to t_1 = u_1 \land \ldots \land t_1 = u_n
\end{equation}

\end{tcolorbox}

\caption{Regole di riscrittura per vincoli di uguaglianza}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotx = t$ e $\dotx$ non è contenuto ne in $t$ ne in altri letterali della fomula.
\end{itemize}

\paragraph{Implementazione}

\begin{verbatim}
eq(T1, T2, R),  T1 == T2 =>                                        % 1
    log_d_vv("eq :: eq_1"),
    R = [].

eq(T1, T2, R), nonvar(T1), var(T2) =>                              % 2
    log_d_vv("eq :: eq_2"),
    R = [ $eq(T2, T1) ].

eq(T1, T2, R), 
        var(T1), T2.is_lset(),
	    not occur_check(T1, T2.lset_head()),
        T1 == T2.lset_rest() =>                                    % 3
    log_d_vv("eq :: eq_3"),
    YSetNew = new_lset(T2.lset_head(),_N),
    R = [ $eq(T1, YSetNew) ].

eq(T1, T2, _R), 
        var(T1),
        occur_check(T1, T2) =>                                     % 4
    log_d_vv("eq :: eq_4"),
    fail.  % sic.

eq(T1, T2, R), 
        var(T1) =>                                                 % 5
    log_d_vv("eq :: eq_5"),
    R = [], T1 = T2.

eq(T1, T2, _R), 
        struct(T1), struct(T2), 
        T1.name() !== T2.name() =>                                 % 6
    log_d_vv("eq :: eq_6"),
    fail.  % sic.

eq(T1@[X|Xs], T2, R), 
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7a
    log_d_vv("eq :: eq_7a"),

    YH = T2.lset_head(),                   % head of T2.
    foreachnd_slice(YH, YElem, YSlice),    % get the j-th element nondet.
    YRest = T2.lset_rest(),                % rest of T2.
    YSetSliced = new_lset(YSlice, YRest),  % build T2 without j-th elem.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(Xs, YSetSliced) ],

    R = R1 ++ R2.

eq(T1@[X|_], T2, R), 
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7b
    log_d_vv("eq :: eq_7b"),

    YH = T2.lset_head(),                   % head of T2.
    foreachnd_slice(YH, YElem, YSlice),    % get the j-th element nondet.
    YRest = T2.lset_rest(),                % rest of T2.
    YSetSliced = new_lset(YSlice, YRest),  % build T2 without j-th elem.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(T1, YSetSliced) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2, R),
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7c
    log_d_vv("eq :: eq_7c"),

    % no slice for T2, only Y elem.
    YH = lset_head(T2),              % head of T2.
    foreachnd_slice(YH, YElem, _),   % get the j-th element nondet.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(Xs, T2) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2, R),
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() =>                        % 7d
    log_d_vv("eq :: eq_7d"),

    XRest = lset_rest(T1),

    XHeadSlice = lset_head(Xs),
    XSetNew = new_lset(XHeadSlice, N),

    YHead = T2.lset_head(),
    YSetNew = new_lset(YHead, N),

    R1 = [ $eq(XRest, [X|N]) ],
    R2 = [ $eq(XSetNew, YSetNew) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8a
    log_d_vv("eq :: eq_8a"),
    R = [ $eq(X,Y), $eq(Xs, Ys) ].

eq(T1@[X|_], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8b
    log_d_vv("eq :: eq_8b"),
    R = [ $eq(X,Y), $eq(T1, Ys) ].

eq(T1@[X|Xs], T2@[Y|_], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8c
    log_d_vv("eq :: eq_8c"),
    R = [ $eq(X,Y), $eq(Xs, T2) ].

eq(T1@[X|Xs], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() =>                              % 8d
    log_d_vv("eq :: eq_8d"),
    R = [  
        $eq( Xs,  [Y|N] ),  
        $eq( [X|N],  Ys ) 
    ].

eq(T1, T2, R),
        T1.struct(), T2.struct(),
        T1.name() == T2.name(),
        T1.arity() == T2.arity() =>                                % 9
    log_d_vv("eq :: eq_9"),
    RR = [],
    foreach(I in 1..T1.arity())
        RR := RR ++ [  $eq( T1[I], T2[I] )  ]
    end,
    R = RR.
\end{verbatim}

\clearpage

\subsection{Il vincolo neq}

\textit{Sintassi:} $t_1 \neq t_2$.\\
\noindent\textit{Semantica informale:} $t_1$ è diverso da $t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:neq_constraints}.

\begin{figure}[H]
	\label{fig:neq_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\neq$\textsubscript{\arabic{equation}}}
		
		If $t, t_i: \text{U}; A,B: \text{Set}$ then:
		
		\begin{equation}
		\text{If } t \text{ is a constant or } t \in \calV, t \neq t \to false
		\end{equation}
		\begin{equation}
		\text{If } t \not\in \calV, t \neq \dotx \to \dotx \neq t
		\end{equation}
		\begin{equation}
		\text{If} \dotx \not\in vars(t_1, \ldots, t_n), \dotx \neq \{ t_1, \ldots, t_n \sqcup \dotx \} \to t_1 \not\in \dotx \lor \ldots \lor t_n \not\in \dotx
		\end{equation}
		\begin{equation}
		\text{If} \dotx \in vars(t), \dotx \neq t \to true
		\end{equation}
		\begin{equation}
		\begin{split}
		\{ t_1 \sqcup & A \} = \{ t_2 \sqcup B \} \to \\
		& N \in \{ t_1 \sqcup A \} \land N \not\in \{ t_2 \sqcup B \} \\
		& N \not\in \{ t_1 \sqcup A \} \land N \in \{ t_2 \sqcup B \}
		\end{split}
		\end{equation}
		\begin{equation}
		f(t_1, \ldots, t_n) \neq g(u_1, \ldots, u_m) \to true
		\end{equation}
		\begin{equation}
		f(t_1, \ldots, t_n) = f(u_1, \ldots, u_n) \to t_1 \neq u_1 \land \ldots \land t_1 \neq u_n
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di non disuguaglianza}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotx \neq t$ e $\dotx$ non compare ne in $t$ ne come argomento di qualunque predicato $p(\ldots)$, $p \in \{ un, id, inv, comp \}$.
\end{itemize}

\paragraph{Implementazione}
\begin{verbatim}
neq(T1, T2, R),
        ground(T1), ground(T2),
    T1 !== T2 =>  % ground
    log_d_vv("neq :: neq_ground"),
    R = [].

neq(T1, T2, R),
        T1 == T2 =>  % 1
    log_d_vv("neq :: neq_1"),
    fail.  % sic.

neq(T, X, R),
        nonvar(T), var(X) =>  % 2
    log_d_vv("neq :: neq_2"),
    R = [ $neq(X, T) ].

neq(X, S, R), 
        S.is_lset(),
        X == S.lset_rest(),
        not occur(X, S.lset_head()) =>  % 3
    log_d_vv("neq :: neq_3"),
    RR = [],
    foreach (T in S.lset_head)
        RR := RR ++ [$nin(T, X)]
    end,
    R = [ $or(RR) ].

neq(X, T, R),
        occur(X, T) =>  % 4
    log_d_vv("neq :: neq_4"),
    R = [].

neq([T1|A], [T2|B], R) ?=>  % 5a
        log_d_vv("neq :: neq_5a"),
    R = [ $inls(N, [T1|A], $nin(N, [T2|B])) ].

neq([T1|A], [T2|B], R) ?=>  % 5b
    log_d_vv("neq :: neq_5a"),
    R = [ $nin(N, [T1|A]), $insl(N, [T2|B]) ].

neq(F, G, R),
        F.struct(), G.struct(),
        F.name() !== G.name() =>  % 6
    log_d_vv("neq :: neq_6"),
    R = [].

neq(F, G, R),
        F.struct(), G.struct(),
        F.arity() !== G.arity() =>  % 7
    log_d_vv("neq :: neq_7"),
    R = [].

neq(X, T, R), 
        not occur(X, T) => % irr
    log_d_vv("neq :: neq_irr"),
    R = [ $neq(X, T) ].
\end{verbatim}

\clearpage

\subsection{Il vincolo in}

\textit{Sintassi:} $t_1 \in t_2$.\\
\noindent\textit{Semantica informale:} se $t_2$ è un insime, $t_1$ è un membro di $t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:in_constraints}.

\begin{figure}[H]
	\label{fig:in_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\in$\textsubscript{\arabic{equation}}}
		
		If $x, y: \text{U}; A: \text{Set}$ then:
		
		\begin{equation}
		x \in \emptyset \to false
		\end{equation}
		\begin{equation}
		x \in \{ y \sqcup A \} \to x = y \lor x \in A
		\end{equation}
		\begin{equation}
		x \in \dotA \to \dotA = \{ x \sqcup N \}
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di appartenenza}
\end{figure}

\paragraph{Forme irriducibili} Nessuna.

\paragraph{Implementazione}
\begin{verbatim}
insl(X, S, R) => 
    log_d_vv("insl :: -> contains"),
    contains(S, X, R).

contains(S, X, R),
        S.is_lset(),
        S.is_emptyset() =>                                         % 1
    log_d_vv("contains :: cont_1"),
    fail.

contains(S@[Y|A], X, R),
        S.is_lset() ?=>                                            % 2a
    log_d_vv("contains :: cont_2a"),
    R = [ $eq(X, Y) ].

contains(S@[Y|A], X, R),
        S.is_lset() =>                                             % 2b
    log_d_vv("contains :: cont_2b"),
    R = [ $contains(A, X) ].

contains(A, X, R),
        var(A) =>                                                  % 3
    log_d_vv("contains :: cont_3"),
    YN = new_lset(X, N),
    R = [ $eq(A, YN) ].
\end{verbatim}

\clearpage

\subsection{Il vincolo union}

\textit{Sintassi:} $un(t_1, t_2, t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi,  allora $t_3 = t_1 \cup t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:un_constraints}.

\begin{figure}[H]
	\label{fig:un_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\cup$\textsubscript{\arabic{equation}}}
		
		If $t: \text{U}; A, B, C: \text{Set}$ then:
		
		\begin{equation}
		un(A,A,B) \to A = B
		\end{equation}
		\begin{equation}
		un(A,B,\emptyset) \to A = \emptyset \land B = \emptyset
		\end{equation}
		\begin{equation}
		un(\emptyset,A,\dotB) \to \dotB = A
		\end{equation}
		\begin{equation}
		un(A,\emptyset,\dotB) \to \dotB = A
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (\{ t \sqcup C \}, A, \dotB) \to \\
		  & (t \not\in A \land un(N_1, A, N) \\
		  & \lor A = \{ t_1 \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		  & \land \{ t\sqcup C \} = \{ t \sqcup N_1 \} \land \dotB = \{ t\sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (A, \{ t \sqcup C \}, \dotB) \to \\
		& (t \not\in A \land un(N_1, A, N) \\
		& \lor A = \{ t_1 \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		& \land \{ t\sqcup C \} = \{ t \sqcup N_1 \} \land \dotB = \{ t\sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		un & (A, B, \{ t \sqcup C \}) \to \\
		& (A = \{t \sqcup N_1 \} \land un(N_1, N_2, N) \\
		& \lor B = \{ t \sqcup N_1 \} \land un(A, N_1, N) \\
		& \lor A = \{ t \sqcup N_1 \} \land B = \{ t \sqcup N_2 \} \land un(N_1, N_2, N) ) \\
		& \land \{ t \sqcup C \} = \{ t \sqcup N \}
		\end{split}
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di appartenenza}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $un(\dotA, \dotB, \dotC)$, $\dotA$ e $\dotB$ variabili distinte.
\end{itemize}

\paragraph{Implementazione}
\begin{verbatim}
union(S1, S2, S3, R), 
        S1.is_lset(), S2.is_lset(), S3.is_lset(),
        S1 == S2 =>                                                % 1
    log_d_vv("union :: un_1"),
    R = [$eq(S1, S3)].

union(S1, S2, S3, R),
        S1.is_lset(), S2.is_lset(),
        S3.is_emptyset() =>                                        % 2
    log_d_vv("union :: un_2"),
    R = [$eq(S1, S3), $eq(S2, S3)].

union(S1, S2, V, R),
        S1.is_emptyset(),
        S2.is_lset(), 
        var(V) =>                                                  % 3
    log_d_vv("union :: un_3"),
    R = [$eq(V, S2)].

union(S1, S2, V, R),
        S2.is_emptyset(),
        S1.is_lset(), 
        var(V) =>                                                  % 4
    log_d_vv("union :: un_4"),
    R = [$eq(V, S1)].

union(S@[T|C], A, B, R),
        S.is_lset(),
        %S2.is_lset(), 
        var(B) ?=>                                                 % 5a
    log_d_vv("union :: un_5a"),
    R = [ 
        $nin(T, A), 
        $eq(S, [T|N1]), 
        $eq(B, [T|N]),
        $union(N1, A, N)
    ].

union(S@[T|C], A, B, R),
        S.is_lset(),
        %S2.is_lset(), 
        var(B) =>                                                  % 5b
    log_d_vv("union :: un_5b"),
    R = [ 
        $nin(T, A), 
        $eq(S, [T|N1]), 
        $eq(B, [T|N]),
        $union(N1, A, N)  
    ].

union(A, S@[T|C], B, R),
        S.is_lset(),
        %S2.is_lset(), 
        var(B) ?=>                                                 % 6a
    log_d_vv("union :: un_6a"),
    R = [ 
        $nin(T, A), 
        $eq(S, [T|N1]), 
        $eq(B, [T|N]),
        $union(N1, A, N)  
    ].

union(A, S@[T|C], B, R),
        S.is_lset(),
        %S2.is_lset(), 
        var(B) =>                                                  % 6b
    log_d_vv("union :: un_6b"),
    R = [ 
        $nin(T, A), 
        $eq(S, [T|N1]), 
        $eq(B, [T|N]),
        $union(N1, A, N)  
    ].

union(S1, S2, S3@[Z|Zs], R),
        S1.is_lset(),
        S2.is_lset(),
        S3.is_lset() ?=>                                           % 7a
    log_d_vv("union :: un_7a"),
    R1 = [ $eq(S1,[Z|N1]), $union(N1,B2,N) ],
    R4 = [ $eq(S3,[Z|N]) ],

    R = R1 ++ R4.

union(S1, S2, S3@[Z|Zs], R),
        S1.is_lset(),
        S2.is_lset(),
        S3.is_lset() ?=>                                           % 7b
    log_d_vv("union :: un_7b"),
    R2 = [ $eq(S2,[Z|N1]), $union(S1,N1,N) ],
    R4 = [ $eq(S3,[Z|N]) ],

    R = R2 ++ R4.

union(S1, S2, S3@[Z|Zs], R),
        S1.is_lset(),
        S2.is_lset(),
        S3.is_lset() =>                                            % 7c
    log_d_vv("union :: un_7c"),
    R3 = [ $eq(S1,[Z|N1]), $eq(S2,[Z|N2]), $union(N1,N2,N) ],
    R4 = [ $eq(S3,[Z|N]) ],

    R = R3 ++ R4.

union(S1, S2, S3, R),
        var(S1), var(S2), var(S3),
        S1 !== S2 =>                                               % irr
    log_d_vv("union :: un_irr"),
    R = [ $union(S1, S2, S3) ].
\end{verbatim}

\clearpage

\subsection{Il vincolo disj}

\textit{Sintassi:} $t_1 \mid\mid t_2$.\\
\noindent\textit{Semantica informale:} se $t_1$ e $t_2$ sono insiemi, allora $t_1 \cap t_2 = \emptyset$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:disj_constraints}.

\begin{figure}[H]
	\label{fig:disj_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{$\mid\mid$\textsubscript{\arabic{equation}}}
		
		If $t, t_i: \text{U}; A, B: \text{Set}$ then:
		
		\begin{equation}
		\emptyset \mid\mid A \to true
		\end{equation}
		\begin{equation}
		A \mid\mid \emptyset \to true
		\end{equation}
		\begin{equation}
		\dotA \mid\mid \dotA \to \dotA = \emptyset
		\end{equation}
		\begin{equation}
		\{ t \sqcup B \} \mid\mid \dotA \to t \not\in \dotA \land \dotA \mid\mid B
		\end{equation}
		\begin{equation}
		\dotA \mid\mid \{ t \sqcup B \} \to t \not\in \dotA \land \dotA \mid\mid B
		\end{equation}
		\begin{equation}
		\{ t_1 \sqcup A \} \mid\mid \{ t_2 \sqcup B \} \to t_1 \neq t_2 \land t_1 \not\in B \land t_2 \not\in A \land A \mid\mid B
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di disgiunzione}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotA \mid\mid \dotB$, $\dotA$ e $\dotB$ variabili distinte.
\end{itemize}

\paragraph{Implementazione}

TODO

\clearpage

\subsection{Il vincolo subset}

\textit{Sintassi:} $t_1 \subseteq t_2$.\\
\noindent\textit{Semantica informale:} se $t_1$ e $t_2$ sono insiemi, allora $t_1$ è un sottoinsieme di $t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:subset_constraints}.

\begin{figure}[H]
	\label{fig:subset_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{\textsubscript{\arabic{equation}}}
		
		If $x, y: \text{U}; A, B: \text{Set}$ then:
		
		\begin{equation}
		\dotA \subseteq \dotA \to true
		\end{equation}
		\begin{equation}
		\emptyset \subseteq A \to true
		\end{equation}
		\begin{equation}
		\dotA \subseteq \emptyset \to \dotA = \emptyset
		\end{equation}
		\begin{equation}
		\{ t \sqcup A \} \subseteq \emptyset \to false
		\end{equation}
		\begin{equation}
		\begin{split}
			\{ x \sqcup A \} & \subseteq \dotB \to \\ 
			  & \dotB = \{ x \sqcup N \} \land A \subseteq \{ x \sqcup N \}
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
			\{ x \sqcup A \} & \subseteq \{ y \sqcup B \} \to \\ 
			  & x = y \land A \subseteq \{ y \sqcup B \} \\ 
			  & \lor x \neq y \land x \in B \land A \subseteq \{ x \sqcup B \}
		\end{split}
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di sottoinsieme}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $\dotA \subseteq \dotB$, $\dotA$ e $\dotB$ variabili distinte;
	\item $\dotA \subseteq \{ y | B \}$.
\end{itemize}

\paragraph{Implementazione}

TODO

\clearpage

\subsection{Il vincolo inters}

\textit{Sintassi:} $inters(t_1,t_2,t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi, allora $t_3 = t_1 \cap t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:intersect_constraints}.

\begin{figure}[H]
	\label{fig:intersect_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{7}
		\renewcommand{\theequation}{$\cup$\textsubscript{\arabic{equation}}}
		
		If $x: \text{U}; A, B, C: \text{Set}$ then:
		
		\begin{equation}
		inters(\dotA, \dotA, B) \to A = B
		\end{equation}
		\begin{equation}
		inters(\emptyset, \dotA, C) \to C = \emptyset
		\end{equation}
		\begin{equation}
		inters(\dotA, \emptyset, C) \to C = \emptyset
		\end{equation}
		\begin{equation}
		inters(A,B,\emptyset) \to A \mid\mid B
		\end{equation}
		\begin{equation}
		\begin{split}
		inters & (A,B,\dotC) \to \\
		  & A = \{ x \sqcup N_1 \} \\
		  & \lor B = \{ x \sqcup N_2 \} \land \dotC = \{ x \sqcup N_3 \} \land inters(N_1, N_2, N_3)
		\end{split}
		\end{equation}
		\begin{equation}
		\begin{split}
		inters & (A,B,\dotC) \to \\
		  & A = \{ x \sqcup N_1 \} \land B = \{ x \sqcup N_2 \} \land inters(N_1, N_2, C)
		\end{split}
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di intersezione}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item $inters(\dotA, B, \dotC)$, $\dotA$ e $B$ non sono la stessa variabile;
	\item $inters(A, \dotB, \dotC)$, $A$ e $\dotB$ non sono la stessa variabile.
\end{itemize}

\paragraph{Implementazione}

TODO

\clearpage

\subsection{Il vincolo diff}

\textit{Sintassi:} $diff(t_1,t_2,t_3)$.\\
\noindent\textit{Semantica informale:} se $t_1, t_2$ e $t_3$ sono insiemi, allora $t_3 = t_1 \setminus t_2$.\\
\noindent\textit{Regole di riscrittura:} \ref{fig:difference_constraints}.

\begin{figure}[H]
	\label{fig:difference_constraints}
	
	\begin{tcolorbox}[colframe=black, colback=white, sharp corners]
		\setcounter{equation}{0}
		\renewcommand{\theequation}{\textsubscript{\arabic{equation}}}
		
		If $A, B, C: \text{Set}$ then:
		
		\begin{equation}
		diff(A,B,C) \to un(C,A,A) \land un(B,C,N) \land un(A,N,N)
		\end{equation}
		
	\end{tcolorbox}
	
	\caption{Regole di riscrittura per vincoli di differenza}
\end{figure}

\paragraph{Forme irriducibili}
\begin{itemize}
	\item Nessuna.
\end{itemize}

\paragraph{Implementazione}

TODO


%%% *******************************************************
%%% Dettagli implementativi
\chapter{Dettagli implementativi}

\section{Il vincolo or}

Molte regole di riscrittura integrate dal solver non contengono solo clausole in congiunzione (legate da $\land$), ma anche clausole in disgiunzione. Questa sottile differenza porta un grosso cambiamento nella gestione del controllo durante la risoluzione di formule. Da un punto di vista algoritmico, mentre le clausole congiunte si possono risolvere una dopo l'altra catturando il primo fallimento per interrompere la computazione, le clausole disgiunte non godono della stessa proprietà. Di fatto, se una clausola in disgiunzione fallisce, non è detto che le altre lo facciano, anzi, spesso non è così. Bisogna quindi essere in grado di tornare al punto in cui si è scelta una delle clausole in \emph{or} da risolvere, ripristinando lo stato del programma, per poter proseguire con la successiva.

Per l'implementazione di questo meccanismo viene in aiuto il \emph{backtracking}, che simula proprio funzionamento in questione. Il backtracking è un algoritmo generale che permette di trovare tutte (o alcune) soluzioni ad un certo problema computazionale, che incrementalmente costruisce nuove soluzione abbandonando quelle che sono state decretate non essere una soluzione. Durante la risoluzione di formule insiemistiche questo si può verificare appunto prendendo una clausola in disgiunzione che non soddisfa i vincoli e provoca il fallimento. Il backtracking in questo caso scarta la soluzione, ripristina il programma al punto di scelta (\emph{choice point}\fixme{Aggiungere una descrizione sommaria di choice point in una footnote})\fixme{Aggiungere citazione a fonte: programming in prolog, altri} e prosegue con un'altra delle clausole non ancora esplorate.

L'implementazione del vincolo or nel solver è costruito in due modi:
\begin{itemize}
\item tramite l'utilizzo di un vincolo ausiliario;
\item sfruttando il backtracking sulla regola esatta che presenta clausole in disgiunzione.
\end{itemize}

Nel primo caso l'implementazione è simile a quella di una regola di riscrittura
\begin{verbatim}
%% or(List, Result) is nondet
%
% @desc Rewrite rule for or constraints.

or([], []) => true.
or([T|_Tr], R) ?=> R = [T].
or([_T|Tr], R) => or(Tr, R).
\end{verbatim}
dove
\begin{itemize}
\item la prima regola gestisce il caso in cui la lista di clausole in or sia vuota, ed ha sempre successo;
\item la seconda regola gestisce la prima riscrittura: estrae una clausola prendendola dalla testa della lista e la inserisce nel risultato;
\item la terza regola gestisce il caso in cui la seconda regola fallisca (ovvero la clausola utilizzata non ha soddisfatto la formula) procedendo con un'altra clausola della lista.
\end{itemize}

\paragraph{Esempio}
\begin{verbatim}
{log} => [eq(X,1),or([eq(X,2),eq(X,1)])]
\end{verbatim}

\begin{itemize}

\item[Step 1] Il risultato della prima riscrittura è
\begin{verbatim}
--- [eq(1,1),or([eq(1,2),eq(1,1)])]
==> [eq(1,2)]
\end{verbatim}
e si può notare come il vincolo \verb|eq(1,1)| sia stato risolto e rimosso dal constraint store risultate, mentre il vincolo \verb|or([eq(X,2),eq(X,1)])| sia stato riscritto in \verb|eq(1,2)|.

\item[Step 2] Il risultato della seconda riscrittura è
\begin{verbatim}
--- [eq(1,1),or([eq(1,2),eq(1,1)])]
==> [eq(1,1)]
\end{verbatim} 
da cui invece è evidente il fallimento nella risoluzione di \verb|eq(1,2)|, e la riscrittura del vincolo \verb|or([eq(X,2),eq(X,1)])| in \verb|eq(1,1)|.

\item[Step 3] Il risultato della terza riscrittura è
\begin{verbatim}
--- [eq(1,1)]
==> []
\end{verbatim}
da cui si nota la risoluzione dell'ultimo vincolo rimasto.

\end{itemize}

\section{Enumerazione delle soluzione}

Il solver per ogni formula può trovare zero, una o più soluzioni, comprendendo anche un numero infinito di soluzioni. L'enumerazione di queste soluzioni è di notevole importanza per \lset{}. Per questo motivo il solver deve essere in grado di cercare altre soluzioni qualora ve ne sinao. Anche in questo caso si ricorre al backtracking.

L'enumerazione di nuove soluzione è infatti implementata forzando un fallimento: tramite il bakctracking si cercano di esplorare strade alternative per la costruzione di altri risultati e se queste alternative sono infinite allora anche questo processo è infinito.

\paragraph{Esempio}
\begin{verbatim}
{log} => [ union( [1|X], [1,2], [1,2] ) ]
\end{verbatim}
ha 4 soluzioni
\begin{itemize}
\item \verb|X = []|;
\item \verb|X = [1]|;
\item \verb|X = [2]|;
\item \verb|X = [1,2]|
\end{itemize}

\section{Predicato eq/3}

Il predicato \verb|eq/3| implementa, senza sorprese, le regole di riscrittura per i vincoli di uguaglianza

 \fixme{Rimuovere da qui??}

%%% *******************************************************
%%% SUso del solver
\chapter{Uso del solver \lset{} da Picat}

In questa sezione vengono dati degli esempi di utilizzo del solver per casi d'uso comuni.

\section{Modalità interattiva}

\subsection{Avvio dell'interprete}

\begin{verbatim}
terminal> picat main.pi

This is the pure implementation of {log} in Picat.
Copyright (C) 2019 Luca Parolari <luca.parolari23@gmail.com>
  This program is free software, covered by the MIT License
  There is ABSOLUTELY NO WARRANTY for this program.
Type 'copying' to see the conditions
Type 'warranty' for details.
Type 'help' for advice, 'quit' to exit.

Default settings follows.

Current log level: [v,vv,vvv]
       Quiet mode: false
         Log file: stdout

log> 
\end{verbatim}

\subsection{Comandi disponibili}

\begin{verbatim}
log> help
Setlog provides you with the following commands:

help
help <what>
    Show help for <what>.
    The argument describes the topic to give help for.
    <what> can be one of [solve]

info
    Display the current interpreter status.

up <n>
    Redo the last <n> command issued.
    If <n> is empty the last command is issued,
    this is equivalent to `up 0`.

log <mode>
    Set the log mode to <mode>.
    Available log mode: [none,v,vv,vvv,all].
log file <file>
    Set log file to <file>.
    Default is `stdout`.

solve
solve <formula>
solve file <file>
    Solve the formula, respectively, typed in stdin,
    given as argument of this command, or read from the
    first line of file <file> using the setlog solver.

quiet <mode>
    Set the quit mode execution.
    Available mode: [true, false]. Default is true.
\end{verbatim}

Il comando \verb|help| mostra un messaggio di aiuto descrivendo i comandi offerti dalla CLI.

\subsection{Configurazione}

\begin{verbatim}
log> info
Current log level: [v,vv,vvv]
       Quiet mode: false
         Log file: stdout
log> log none
log> quiet true
log> info
Current log level: [none]
       Quiet mode: true
         Log file: stdout
\end{verbatim}

\subsection{Risoluzione di formule}

\begin{verbatim}
log> solve                       % formula da stdin
{log} => [ eq(X,1) ]

Vars: (map)[X = 1]
Constraints: []

Another solution? (y/n): y
no!
log>
log> solve [ eq(X,1) ]           % formula come argomento del comando
{log} => [eq(X,1)]
Vars: (map)[X = 1]
Constraints: []

Another solution? (y/n): y
no!
log> 
log> solve file formula1.lset    % formula da file
{log} => [ eq(X,1) ]
Vars: (map)[X = 1]
Constraints: []

Another solution? (y/n): y
no!
log> 
\end{verbatim}

\section{API}

L'utilizzo vero e proprio del solver solitamente non è quello da linea di comando, bensì da altri programmi che lavorano con formule e necessitano di risolvere le stesse per poter combinare i risultati in modelli teorici. E' questo il caso del linguaggio Z \cite{Cristia16}, utilizzato per descrivere formalmente la specifica di programmi. Il linguaggio Z è basato sui concetti e sulla sintassi della matematica, e in particolare della teoria degli insiemi. Le specifiche Z sono convertite in programmi eseguibili, scritti in linguaggi come il Java (si veda \cite{DeSantis17}).

Per questo motivo anche l'implementazione di questo solver fornisce API tramite le quali altri programmi possono interagire con il solver. E' il caso del metodo \verb|solve/2| che come primo argomento riceve una formula e nel secondo argomento restituisce la formula risolta.

\paragraph{Esempio} (pseudocodice)
\begin{verbatim}
%%% my_program.pi

import solver.

my_predicate =>
    do some operations ...

    % solve the formula F with Picat solver
    solve(F, Result),

    use the result Result ...
\end{verbatim}

%%% *******************************************************
%%% Estensioni
\chapter{Esensioni al solver di base}

\minitoc

Per questo lavoro di tesi si sono concentrati gli sforzi nella realizzazione del risolutore di formule stesso, per arrivare ad avere un'implementazione funzionante di \lset{} in Picat, e, di fatto, sono stati tralasciati numerosi dettagli.

Uno dei dettagli non considerati è stato la rappresentazione delle formule. In \ref{sec:ext_formulas} si descrive questo problema e le possibili soluzioni.

\section{Parser di formule}
\label{ext_formulas}

\subsection{Problema}

La sintassi della formula in \lset{} è molto importante: avere una rappresentazione ben definita e fissa permette agli utenti (umani e non) di \lset{} di utilizzare un solver piuttosto che un altro per la risoluzione di formule, senza bisogno di modifiche alla richiesta di risoluzione.

Questo è un concetto molto comune in ingegneria del software: viene impiegata un'interfaccia, rappresentante il contratto che tra fornitore e cliente, per definire formalmente il ruolo delle controparti. In questo caso l'interfaccia è rappresentata dalla sintassi delle formule, ed il solver deve essere in grado di ricevere e restituire formule con la sintassi prestabilita.

In Picat non è stato possibile adottare a livello di linguaggio e costrutti built-in la rappresentazione delle formule di \lset{}. Si è quindi utilizzato una sintassi nettamente più vicnina alla rappresentazione interna di Picat, descritta in \ref{ch:appendix_lset_picat_notations}.

\subsection{Soluzione}

Lo schema sottostante riassume la condizione ottimale in cui la formula non ha bisogno di preprocessing per essere lavorata dal solver.

\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\centering
		\label{fig:formula_lset_solver}
		\begin{tikzpicture}
		[node distance=.8cm,start chain=going below,]
		\node[punktchain, join] (a) {Formule \lset{}\\$X = \{1|Y\}$};
		\node[punktchain, join] (b) {Solver};
		\end{tikzpicture}
	\end{minipage}%
	\begin{minipage}[b]{0.4\textwidth}
		\centering
		\begin{tikzpicture}
		[node distance=.8cm,start chain=going below,]
		\node[punktchain, join] (a) {Formule in rappresentazione Picat\\ 
		    \texttt{ [eq(X, [1|Y])] } };
		\node[punktchain, join] (b) {Solver};
		\end{tikzpicture}
	\end{minipage}
\end{figure}\verb
L'approccio della prima figura non è supportato da Picat per via della sintassi di \lset{}. L'approccio della seconda figura invece è quello adottato, che però non rispetta la sintassi \lset{} per le formule.

La soluzione al problema è riassumibile dallo schema seguente
\begin{figure}[H]
\centering
\begin{tikzpicture}
[node distance=.8cm,start chain=going below,]
\node[punktchain, join] (a) {Formule \lset{}\\ $X = \{1|Y\}$};
\node[punktchain, join] (b) {Formule in rappresentazione Picat\\ \texttt{  [eq(X, [1|Y])]}};
\node[punktchain, join] (c) {Solver};
\end{tikzpicture}
\end{figure}
che aggiunge un livello, il \emph{preprocessing delle formule}, appunto. In questo modo il solver non ha bisogno di mofiche, in quanto manipola sempre le stesse formule, e la sintassi della richiesta diventa conforme a quella di \lset{}.

In questo modo inoltre, si può decidere di non realizzare il preprocessor in Picat, ma in Prolog ad esempio, sfruttando il modulo DCG \cite{MetalevelDCG} (Definite Clause Grammar) che consente di effettuare il parsing di frasi dando la grammatica a clausole definite. 

\chapter{Conclusione e lavori futuri}
TODO


%%% *******************************************************
%%% *   Appendice   ***************************************
\begin{appendices}

\chapter{Notazioni per \lset{} in Picat}
\label{ch:appendix_lset_picat_notations}

Per semplificare l'implementazione si è deciso di adottare alcuni espedienti notazionali descritti dalle sezioni sottostanti.\footnote{La notazione impiegata in \clpset{} è descritta in \ref{sec:lang_clpset}.}. Ciò si è reso necessario per evitare di affrontare problemi non direttamente legati al solver e potersi concentrare solamente sulla risoluzione dei vincoli insiemistici.

\section{Formule}

La notazione adottata per la rappresentazione delle formule è la seguente:

\begin{table}[H]
\center
\begin{tabular}{ll}
\textbf{Linguaggio} & \textbf{Notazione} \\
\lset{} & $T_1 \land T_2 \land \ldots \land T_n$ \\
Picat & \verb|[| $T_1, T_2, \ldots, T_n$\verb|]| \\
\end{tabular}
\end{table}

\section{Operazioni primitive}

Le operazioni primitive di \clpset{} sono spesso espresse tramite simboli (e.g., $=, \neq, \ldots$). La notazione adottata è la seguente:

\begin{table}[H]
\center
\begin{tabular}{l l}
\textbf{Linguaggio} & \textbf{Notazione} \\
\lset{} & $T_1 = T_2$ \\
Picat & \verb|[eq(| $T_1, T_2$ \verb|)]| \\
\end{tabular}
\end{table}

\section{Insiemi}

Gli insiemi in \clpset{} sono rappresentati tramite la funzione $\{ \cdot \mid \cdot \}$.

\begin{table}[H]
\center
\begin{tabular}{l l}
\textbf{Linguaggio} & \textbf{Notazione} \\
\lset{} & $\{ T_1, T_2, \ldots, T_n \mid X \}$ \\
Picat & \verb|[| $T_1, T_2, \ldots, T_n \mid X$ \verb|]| \\
\end{tabular}
\end{table}

\end{appendices}


%%% *******************************************************
%%% *   Bibliograpy   *************************************
\printbibliography

\end{document}