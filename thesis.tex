\documentclass[12pt,a4paper,openright]{book} % oneside

%   PACKAGES
\usepackage{lmodern}         % font package.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[italian]{babel}  % italian latex typo conventions.
\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{listings}        % embed programming language in latex.
\usepackage{stmaryrd}        % symbols for theoretical computer science.
\usepackage{hhline}          % better horizontal lines in tabulars and arrays.
%%\usepackage{vmargin}         % various page dimensions.
\usepackage{hyperref}        % hypertext support.
\usepackage{makeidx}         % for creating indexes.
\usepackage{nicefrac}        % inline fractions.
\usepackage{marginnote}      % notes in the margin, even where \marginpar fails.
\usepackage{xr}              % references to other latex documents.
\usepackage{subfiles}        % multifile support.
\usepackage{geometry}        % interface for document dimension.
\usepackage{graphicx}        % enhanced support for graphics.
\usepackage{fancyhdr}        % extensive control of page headers and footers.
\usepackage{lipsum}          % generate dummy text.
\usepackage[backend=biber,style=numeric]{biblatex}  % bib management. %bibtex
\usepackage{minitoc}         % table of contents per chapter.
\usepackage{listings}        % code sections, http://ctan.org/pkg/listings
%\usepackage{showframe}      % shows page frames.
\usepackage{titlesec}        % change titles size.
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}

%   CONFIGS
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=blue}
\dominitoc
\lstset{
  basicstyle=\ttfamily,
  mathescape
}
\titleformat*{\subsubsection}{\large\bfseries}

%   RESOURCES
\subfile{prooftree}
\input{macros.tex}
\addbibresource{biblio.bib}


% **********************************************
% **********************************************
\begin{document}

%%% First page
\begin{titlepage}
    \begin{center}       
        \includegraphics[width=0.4\textwidth]{img/logo_unipr.png}

		\vspace{0.5cm}
		
		% *** university details
		\Large
        Dipartimento di Scienze Matematiche\\
        Fisiche ed Informatiche

        \vspace{0.5cm}
        
        \Large
        Corso di laurea in Informatica 
		
		\vspace{1.5cm} 
 
 		% *** title
        \Huge
        \textbf{Progettazione ed implementazione in Picat di un risolutore per vincoli insiemistici}
 
 		% *** subtitle
        \vspace{1cm}
        \LARGE
        % may have subtitle.
 
        \vspace{1.5cm}
 
 		% *** authors
		\large Candidato: \Large\textbf{Luca Parolari}\\
		\large Relatore: \Large\textbf{Gianfranco Rossi}
	
		%\begin{minipage}{0.4\textwidth}
		%	\begin{flushleft}
		%		\large
		%		\textit{Author}\\
		%		B.J. \textsc{Blazkowicz} % Your name
		%	\end{flushleft}
		%\end{minipage}
		%
		%\begin{minipage}{0.4\textwidth}
		%	\begin{flushright}
		%		\large
		%		\textit{Supervisor}\\
		%		Dr. Caroline \textsc{Becker} % Supervisor's name
		%	\end{flushright}
		%\end{minipage}
		
        \vfill
 		
 		\large
        Tesi di Laurea in Informatica\\
        Anno Accademico 2018-2019
 
    \end{center}
\end{titlepage}

%%% Dedication
%\begin{dedication}
%test
%\end{dedication}

%%% TOC
\tableofcontents

%\lhead[\fancyplain{}{}]{\fancyplain{}{\leftmark}} \chead{}
%\rhead{\thepage} \lfoot{} \cfoot{} \rfoot{}


%%% *******************************************************
%%% Introduzione
\chapter*{Introduzione}

\lipsum[1-4]


% TODO da definire
%%% *******************************************************
% Panoramica e background
%\chapter{Panormaica e background}
%
%\minitoc
%
%In questo capitolo si vuole dare un'infarinatura sull'ambito dei linguaggi trattati in questo lavoro di tesi.


%%% *******************************************************
% Linguaggi a vincoli basati su insiemi e relazioni bianrie
\chapter{Linguaggi a vincoli basati su insiemi e relazioni binarie}
\label{ch:sets-binrel-based-constraint-languages}

\minitoc

In questo capitolo vengono presentati e contestualizzati due linguaggi orientati alla risoluzione di formule insiemistiche: \clpset{} e \lbr{}. Entrambi i linguaggi seguono il paradigma della programmazione logica e, più precisamente essendo basati su vincoli, della programmazione logica con vincoli (o \textit{Constraint Logic Programming}). Nelle sezioni \ref{sec:logic_programming} e \ref{sec:constraint_logic_programming} sono descritti rispettivamente i due paradigmi in forma molto discorsiva ed introduttiva.

Nella sezione \ref{sec:lang_clpset} si da una definizione di \clpset{}, un linguaggio a vincoli basato su insiemi. 
Nel capitolo XXX è descritta l'implementazione di questo linguaggio in Picat, obiettivo di questo lavoro di tesi.

Nella sezione \ref{sec:lang_lbr} è invece definito \lbr{}, un linguaggio che estende ed include \clpset{}, interamente basato su vincoli su relazioni binarie.

\section{Logic Programming}
\label{sec:logic_programming}

La programmazione logica (o \emph{logic programming}, spesso abbreviato in \emph{LP}) è un paradigma di programmazione dove gli \emph{statements} del programma rappresentano fatti o regole, espressi tramite qualche logica formale, di un problema. La logica viene utilizzata come meccanismo formale per analizzare le inferenze in termini di operazioni su espressioni simboliche, dedurre conseguenze da un insieme di premesse, studiare la verità (o falsità) di un insieme di proposizioni, data la verità (o falsità) di altre proposizioni e dimostrare la validità di una teoria. Questi concetti possono essere approfonditi in \cite{Console97}.

\paragraph{Esempio}
Programma logico in Prolog.
\begin{verbatim}
% Giovanni è padre di Antonio.
padre(giovanni, antonio).
padre(giovanni, riccardo).
padre(mario, giovanni).

% X è nonno di Y se X è padre di Z e Z è padre di Y.
nonno(X, Y) :- padre(X, Z), padre(Z, Y).

?- nonno(X, antonio).
X = mario.
\end{verbatim}

Nel campo dell'informatica la logica trova molteplici applicazioni in ambiti per lo più di intelligenza artificiale. La logica, sotto opportune ipotesi, può diventare un vero e proprio linguaggio di programmazione, prendendo appunto il nome di Logic Programming. Spesso i linguaggi di programmazione di questo tipo adottano un approccio dichiarativo, descrivendo solamente la forma della soluzione e non la procedura per ottenerla (e.g., il Datalog). Per i linguaggi come il Prolog o Picat invece l'approccio può essere ibrido: il paradigma dichiarativo, imperativo e procedurale si intersecano lasciando al programmatore la scelta del paradigma da usare.

La logica classica si può suddividere in due classi principali: la \emph{logica proposizionale} e la \emph{logica dei predicati}.  I più comuni linguaggi logici sono basati su un sottoinsieme della logica dei predicati del primo ordine, che permette di garantire la correttezza delle soluzioni ma non la terminazione del programma. Entrambe, comunque, permettono di esprimere proposizioni (frasi) e
relazioni tra posizioni. La principale differenza tra le due è l'espressività. Ciò che può essere espresso nella logica dei predicati può essere espresso nella logica proposizionale, ma non viceversa. La logica dei predicati consente di utilizzare \textbf{variabili} e quantificazioni su di esse, mentre nella logica proposizionale non è possibile.

I programmi logici vengono risolte mediante sistemi di deduzione. Il più famoso ed usato è il \emph{Principio di Risoluzione}, che adotta un'unica regola di infereza. Questo metodo di risoluzione è applicabile a teorie del primo ordine in forma di clausole, ed è notevolmente efficiente.

\section{Constraint Logic Programming}
\label{sec:constraint_logic_programming}
La programmazione logica basata su vincoli estende la programmazione logica introducendo il concetto di \emph{vincolo}. Un programma CLP contiene fatti e regole come un programma LP, con la differenza che nel programma CLP il corpo delle clausole può presentare vincoli.

Per i CLP il risultato di una dimostrazione è quindi un insieme di vincoli (contraint store) e/o un valore letterale valido in quell'insieme di vincoli.

La programmazione logica basata su vincoli è utilizzata per risolvere \emph{Contraint Satisfaction Problem} (spesso abbreviato in \emph{CSP}). Un problema di soddisfacimento di vincoli è intrinsicamente legato al dominio dei suoi vincoli, ciò rende il CSP parametrico rispetto al diminio dei suoi vincoli. Per questo motivo, il nome \clpset{} esprime il linguaggio basato su vincoli  dove il dominio del vincolo è l'insieme.

\subsection{Constraint Satisfaction Problem}
\label{sec:constraint_satisfaction_problem}
Un problema di soddisfacimento di vincoli è una tripla composta da
\begin{itemize}
\item un insieme $X$ di variabili ${X_1, \ldots, X_n}$;
\item un insieme $D$ di domini ${D_1, \ldots, D_n}$, uno per variabile;
\item un insieme $C$ di vincoli che specificano le combinazioni di valori possibili per le variabili.
\end{itemize}

Ogni dominio $D_i$ specifica un insieme di valori possibili per la variabile $X_i$.

\section{Il linguaggio $\clpset$}
\label{sec:lang_clpset}
\clpset{}, definito in \cite{Dovier00} è un linguaggio logico per la gestione di vincoli su insiemi. Da un punto di vista più generale \clpset{} è un istanza dei CLP sopra descritti, dove il dominio di applicazione dei vincoli è quello insiemistico. In questo contesto gli insiemi sono visti come un tipo di dato primitivo del linguaggio, detti termini della logica del primo ordine. I predicati predefiniti invece sono visti come vincoli predefiniti del linguaggio, gestiti con procedure di risoluzione di vincoli. 

La classe di insiemi considerata vuole essere molto generale: gli insiemi possono essere annidati e/o parzialmente specificati. Gli insiemi parzialmente specificati possono contenere variabili e altri elementi \emph{non-ground}.

Uno degli obiettivi primari di \clpset{} è di essere molto flessibile e fornire forme generali per la manipolazione di insiemi e relative operazioni, in quanto la nozione di \emph{set} è una componente comune nella progettazione di programmi, ma sono pochi i linguaggi che forniscono gli insiemi come struttura dati elementare.
Sempre in \cite{Dovier00} vengono menzionate alcune eccezioni di linguaggi che si basano su insiemi: SETL, B ed il linguaggio Z, utilizzato per descrivere la specifica formale di programmi. Qualche eccezione esiste anche nel campo dei \emph{database deduttivi} e, più recentemente, anche come \emph{general purpose programming language}. Ad ogni modo, questi linguaggi impongono dei limiti sul tipo di insiemi espressibili o sulle capacità computazionali degli stessi. Ad esempio, in molti ambiti, si richiede che gli insiemi siano totalmente specificati: non sono ammesse \emph{variabili} libere.

Si noti che in \clpset{} il costo computazione non è un requisito necessario. Molte operazioni possono risultare anche molto costose, ma dal punto di vista implementativo si preferisce implementare la risoluzione al problema in modo dichiarativo e più intuitivo possibile.

Di seguito si darà una descrizione tradizionale di \clpset{} definendone prima la sintassi (\ref{subsec:lang_clpset_sintax}) e poi la semantica informale (\ref{subsec:lang_clpset_semantics}). In \ref{subsec:lang_clpset_solver} si descriverà il funzionamento in termini astratti del risolutore di formule per questo linguaggio, implementato in questo lavoro di tesi.

\subsection{Sintassi}
\label{subsec:lang_clpset_sintax}

La sintassi del linguaggio \clpset{} si basa sui seguenti insiemi di simboli:

\begin{itemize}
\item $\calF$ è un insieme di costanti e simboli di funzione definito da:    
\begin{itemize}
\item $\emptyset \in \calF$,
\item $\{ \cdot \mid \cdot \} \in \calF$ e $int \in \calF$, simboli relazione binaria,
\item $Z \subset \calF$ e $F_Z \subset \calF$, dove $Z$ l'insieme delle costanti numeriche intere e $F_Z$ l'insieme degli operatori aritmetici di base (+, -, $\ast$, /);
\end{itemize}
\item $\prod_C = \{ =, in, un, disj, \leq, size, set, integer \}$, insieme di simboli di predicato;
\item $\calV$ è un insieme numerabile di simboli di variabile.
\end{itemize}

I \lset{}-\textit{termini} sono termini costruiti a partire dai simboli di $\calF$ e $\calV$ nel modo usuale. Ad esempio, i seguenti, sono termini insiemistici ($set-terms$):
\begin{itemize}
\item $\{1 \mid \emptyset \} \equiv \{1\}$
\item $\{1 \mid \{2 \mid \emptyset \} \} \equiv \{1,2\}$
\item $\{1 \mid \{2 \mid X \} \} \equiv \{1,2 \mid X \}$
\item $\ldots$
\end{itemize}
    
I \lset{}-\textit{constraint} atomici (o primitivi) sono predicati i cui simboli sono definiti in $\prod_C$, come:
\begin{itemize}
\item $X = 1$
\item $un(\{1\}, \emptyset, R)$
\end{itemize}
    
Le \lset{}-\textit{formula} (o \lset{}-\textit{constraint} composti) sono combinazioni $\wedge$ (and) e $\vee$ (or) di \lset{}-\textit{constraint} primitivi. Le seguenti formule sono esempi di \lset{}-\textit{constraint} composti:
\begin{itemize}
\item $1 in R \land 1 nin S \land inters(R,S,T) \land T = \{X\}$
\item $inters(R, S, T) \land size(T, N) \land N \leq 2$
\end{itemize}

\subsection{Semantica informale}.
\label{subsec:lang_clpset_semantics}

La semantica intuitiva dei vari simboli in $\sum_{\mathcal{SET}}$ è la seguente:

\begin{itemize}
\item $\emptyset$ rappresenta l’insieme vuoto;
\item $\{\cdot\mid\cdot\}$ rappresenta il costruttore di insiemi definito come $\{t\mid s\} = \{t\}\ \cup s$;
\item \textit{int} è il costruttore di intervalli definito come
\begin{equation}
int (m, n ) =
  \begin{cases}
    \emptyset & \text{se } m > n \\
    [ m, n ] & \text{se } m \leq n
  \end{cases}
\end{equation}
\item $+, -, \ast, /$ rappresentano le usuali operazioni aritmetiche su interi;
\item il predicato $=$ rappresenta la relazione di uguaglianza;
\item il predicato \textit{in} rappresenta la relazione di appartenenza;
\item il predicato \textit{un} rappresenta la relazione di unione; insiemistica definita come:
$un(r,s,t) = true \Longleftrightarrow t = r \cup s$;
\item il predicato \textit{disj} rappresenta la relazione di disgiunzione insiemistica definita come
$disj(r,s) = true \Longleftrightarrow r \cap s = \emptyset$;
\item il predicato \textit{size} rappresenta la relazione cardinalità di insiemi definita come $size(s, n) = true \Longleftrightarrow n = \mid s \mid$;
\item il predicato $\leq$ rappresenta la relazione di confronto ”minore o uguale” sugli interi;
\item il predicato \textit{set} controlla che il termine sia un insieme.
\end{itemize}
%\subsubsection{Vincoli}

\subsection{Il solver \satset{}}
\label{subsec:lang_clpset_solver}
La procedura \satset{} risolve i vincoli e rappresenta il solver del linguaggio \clpset{}. Il seguente algoritmo ne descrive la struttura:

\begin{algorithm}
\begin{algorithmic}[1]
\Procedure{\satset{}}{}
\State $C \gets $ \texttt{sort\_infer($C$)};
\Repeat
\State $C'$ $\gets C;$
\Repeat
\State $C'' \gets C;$
\State $C \gets $ \texttt{step($C$)};
\Until {$C$ = $C''$;}
\State $C \gets $ \texttt{remove\_neq($C$)};
\Until {$C'$ = $C$;}
\State
\State\Return $C$;
\EndProcedure
\end{algorithmic}
\end{algorithm}

Essenzialmente \satset{} utilizza tre procedure:

\begin{itemize}
\item \textbf{\texttt{sort\_infer}}: aggiunge alla \lset{}-\textit{formula} $C$ i vincoli \textbf{set} e \textbf{integer} per assicurare che gli oggetti utilizzati nei vincoli siano del tipo corretto.
    
\item \textbf{\texttt{step}}: applica speciali \textit{regole di riscrittura} alla formula $C$ corrente e ritorna \textit{false} oppure la formula modificata. L'esecuzione di $STEP$ viene iterata fino ad arrivare ad ottenere una formula in forma irriducibile. Notare che $STEP$ ritorna $false$ se almeno uno dei vincoli in $C$ viene riscritto a $false$. Anche $STEP(false)$ ritorna $false$.
    
\item \textbf{\texttt{remove\_neq}}: tratta l'eliminazione dei $\neq-constraints$ nel caso in cui coinvolgano variabili insiemistiche che appaiono anche in vincoli di unione in forma risolta.
\end{itemize}

Quando la computazione non deterministica di $\satset{}(C)$ termina, se il risultato è $false$ allora si può concludere che $C$ non è soddisfacibile; al contrario, se nessuno dei vincoli in $C$ viene riscritto a $false$ allora ogni soluzione generata da \satset{} è una soluzione per $C$ e viceversa.

\section{Il linguaggio $\lbr$}
\label{sec:lang_lbr}

Il linguaggio \lbr{} estende il linguaggio \clpset{}, precedentemente decritto, con relazioni binarie.
La sintassi di \lbr{} è sostanzialmente la stessa di \clpset{}.
Si richiede soltanto che l'insieme $\calF$ venga esteso con almeno il simbolo binario $(\cdot \mid \cdot)$, usato per rappresentare coppie.
Inoltre l'insieme $\prod_C$ viene esteso con nuovi simboli di predicato su relazioni binarie, precisamente $comp, id$, $inv$ e $rel$.

L'insieme $\prod_C$ esteso descritto da:\\
\begin{center}
\begin{equation}
\prod_C = 
  \{  =, in, un, disj, \leq, size, set, integer  \}
    \cup
  \{  comp, id, inv, rel  \}
\end{equation}
\end{center}
Anche il solver \satset{} viene esteso con le opportune regole di riscrittura per i nuovi vincoli $comp, id$ e $inv$, prendendo poi il nome di \satbr{}. La procedura \texttt{remove\_neq} viene estesa con il supporto ai nuovi vincoli.

\subsection{Vincoli su relazioni binarie}
\textit{Un termine insiemistico r rapperesenta una relazione binaria se assume una delle seguenti forme:}

\begin{itemize}
\item $r = \{\}$

\item $r =
	\{
		( x_1, y_1 ), 
		( x_2, y_2 ),
		\ldots, 
		( x_n, y_n )
    \}$
    
\item $r =
	\{
		( x_1, y_1 ), 
		( x_2, y_2 ),
		\ldots, 
		( x_n, y_n )
		\mid
		S
    \}$, con $S$ relazione binaria
\end{itemize}
dove
\begin{itemize}
    \item[-] $x_i, y_i$ con $i = 1, \ldots, n$ sono termini;
    \item[-] $S$ può essere sia una variabile che un termine insiemistico.    
\end{itemize}

Di seguito viene data una semantica informale dei vincoli primitivi per relazioni binarie.

\begin{itemize}
\item $comp(r,s,t)$: dove $r$, $s$ e $t$ sono relazioni binarie. L’interpretazione intuitiva del vincolo è
\[
    comp(r, s, t) = true 
      \Longleftrightarrow 
    t = \{[x, z] \mid \exists y.[x, y] \in r \land [y, z] \in s\}
\]
    
\item $id(r,I)$: dove \textit{I} è un insieme e \textit{r} una relazione binaria che ne rappresenta l'identità. L’interpretazione intuitiva del vincolo è
\[
    id(r, I) = true 
      \Longleftrightarrow
    r = \{[x, x] \mid x \in I\}
\]

\item $inv(r,s)$: dove $r$ ed $s$ sono relazioni binarie. L’interpretazione intuitiva del vincolo è
\[
   inv(r, s) = true 
     \Longleftrightarrow 
   s = \{[y, x] \mid \exists [x, y] \in r\}
\]
\end{itemize}

I vincoli \textit{dom} e \textit{ran} vengono realizzati come vincoli primitivi nonostante sia dimostrato che possono essere realizzati come vincoli derivati (cioè definiti tramite una formula \lbr{}). Questo viene fatto per motivi di efficienza.

\begin{itemize}
\item $dom(r, A)$: dove $r$ è una relazione binaria e $A$ un insieme che rappresenta il suo dominio. L’interpretazione intuitiva del vincolo è
\[
    dom(r, A) = true 
      \Longleftrightarrow 
    A = \{x \mid \exists [x,y] \in r\}
\]

\item $ram(r, B)$: dove $r$ è una relazione binaria e $B$ un insieme che rappresenta il suo codominio (o rango). L’interpretazione intuitiva del vincolo è
\[
    ran(r, B) = true 
      \Longleftrightarrow 
    B = \{y \mid \exists [x,y] \in r\}
\]
\end{itemize}

\paragraph{Esempi}
\begin{itemize}
\item $dom(\{(1,2), (3,4)\}, \{1,3\}) \implies true$
\item $ran(\{(1,2), (3,4)\}, \{2,4\}) \implies true$
\item $comp(\{(1,2), (3,4)\}, \{(2,6), (4,8)\}, \{(1,6), (3,8)\}) \implies true$
\item $id(\{(1,1), (2,2)\}, \{1,2\}) \implies true$
\item $inv(\{(1,2), (3,4)\}, \{(2,1), (4,3)\}) \implies true$
\end{itemize}

\phantom{a}
I \textit{constraint} primitivi precedentemente definiti possono essere utilizzati in congiunzione tra loro (assieme a nuove varibili ove necessita) per definire altri vincoli (\textit{vincoli derivati}), ad esempio come segue:
\begin{equation}
\begin{split}
dres(A, R, S) & \Longleftrightarrow un(S, N_1, R) \\ 
  & \land dom(S, N_2) \\
  & \land N_2 \subseteq A \\
  & \land dom(N_1, N_3) \\
  & \land A \parallel N_3
\end{split}
\end{equation}
\begin{equation}
\begin{split}
rres(A, R, S) & \Longleftrightarrow un(S, N_1, R) \\ 
  & \land ran(S, N_2) \\
  & \land N_2 \subseteq A \\
  & \land ran(N_1, N_3) \\
  & \land A \parallel N_3
\end{split}
\end{equation}

che rappresentano rispettivamente i vincoli di dominio ristretto ($dres$) e di codominio ristretto ($rres$).

\paragraph{Esempi}
\begin{itemize}
\item $dres\big(\{1,3\}, \{(1,2), (3,4), (5,6)\}, \{(1,2), (3,4)\}\big) \implies true$
\item $rres\big(\{(1,2), (3,4), (5,6)\}, \{2,4\}, \{(1,2), (3,4)\}\big) \implies true$
\end{itemize}

Anche i vincoli negativi $ndom, nran, ncomp, nin$ e $ninv$ vengono definiti in termini dei vincoli primitivi sopra citati.

\subsection{Vincoli su funzioni parziali}
\textit{Un termine insiemistico f rappresenta una funzione parziale se è una relazione binaria e vale la seguente definizione:}
\[
\forall x, y, y' : \big((x, y) \in f \wedge (x, y' ) \in f \implies y = y' \big)
\]

Le funzioni parziali aggiungono il nuovo vincolo \textit{pfun} all'insieme dei vincoli su relazioni binarie.
Il vincolo \textit{pfun} viene introdotto come vincolo primitivo nonostante anch'esso sia dimostrato essere possibile realizzarlo come vincolo derivato. Anche in questo caso si preferisce questa implementazione per motivi di efficienza.

\paragraph{Sintassi}
\begin{itemize}
\item \textit{pfun(f)}: dove $f$ è una relazione binaria.
\end{itemize}

\paragraph{Interpretazione intuitiva}
\[
f = \{ (x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n) \}
\]
allora
\begin{align*}
pfun(f) & = true \Longleftrightarrow \\
  & \forall x_i, x_y \in \{ x_1, \ldots, x_n \} \subset dom(f): \\
    & x_i \neq x_j \land \{ x_1, \ldots, x_n \} \not\in dom(S)
\end{align*}

Quindi se $pfun(f) = true$ allora $f$ è una funzione parziale altrimenti $f$ è una relazione binaria.

\paragraph{Nota}
Anche le funzioni parziali hanno i vincoli di $dom$ e $comp$ che rispettano le definizioni date in precedenza, ma hanno un diverso funzionamento e diconseguenza una diversa implementazione.

Ad esempio, se $r$ è una relazione binaria e $f$ una funzione parziale:
\begin{itemize}
\item $dom(f,\{1\}) \to f = \{(1,n)\}$
\item $dom(r,\{1\}) \to r = \{(1,n_1), \cdots, (1,n_m)\}$ con $m \geq 1$
\end{itemize}


%%% *******************************************************
%%% Picat
\chapter{Picat}

\minitoc

In questo capitolo viene presentato Picat, un linguaggio di programmazione multiparadigma basato sulla logica. Picat è per certi versi molto simile al Prolog, ma dispone di molte funzionalità che modificano radicalmente l'utilizzo comune sia di un linguaggio imperativo che logico.

Nella sezione \ref{sec:picat_features} si descrivono le carrateristiche di Picat, mentre in \ref{sec:picat_base} e \ref{sec:picat_advanced} se ne espongono le funzionalità fornendo esempi esplicativi. Non essendo questa una traduzione della guida utente per Picat, si invita il lettore ad approfondire i numerosi dettagli tralasciati per ovvi motivi in questa presentazione sul manuale \cite{PicatGuide}. Si avvisa inoltre che al tempo in cui si sta scrivendo, la guida di Picat è in versione 2.6.

\section{Caratteristiche}
\label{sec:picat_features}

Picat incorpora le principali funzionalità dei linguaggi logici, funzionali e di scripting. Le caratteristiche di Picat sono riassunte dalle lettere del suo nome:
\begin{itemize}
\item \textbf{P}attern-matching. Un \emph{predicato} definisce una relazione e può avere zero, una o più soluzioni. Picat è un linguaggio basato su regole. I predicati e le funzioni sono definiti tramite regole di pattern-matching.
\item \textbf{I}ntuitive. Picat fornisce comandi come l'assegnamento ed i loop, che vengono usati nei comuni linguaggi imperativi, rendendolo di fatto più affine per la scrittura di programmi "comuni".
\item \textbf{C}onstraints. Picat supporta la programmazione con vincoli. Nasce infatti con quattro moduli per la risoluzione di vincoli: \verb|cp|, \verb|sat|, \verb|smt| e \verb|mip|.
\item \textbf{A}ctors. Viene fornito il supporto a chiamate event-driven tramite \emph{action rules}, utilizzate per descrivere il comportamento degli attori event-driven.
\item \textbf{T}abling. Il tabling è utilizzato per memorizzare la soluzione di un calcolo in memoria, permettendo quindi una rapida consultazione del risultato senza ricalcolo. Per questo motivo, il modulo \verb|planner| di Picat ne fa largo uso. 
\end{itemize}

Inoltre, Picat supporta le maggiori caratteristiche dei linguaggi logici, obbligando però il programmatore ad usarle in modo esplicito, come per il caso dell'unificazione, del non determinismo, del tabling e dei vincoli.

\section{Funzionalità di base}
\label{sec:picat_base}

\subsection{Il sistema Picat}

Picat è un linguaggio interpretato. I programmi Picat però, prima di essere eseguiti, sono compilati. Il compilatore non trasforma i sorgenti in codice macchina, ma depura il programma da tutto quello che non è necessario per l'esecuzione, esegue alcuni controlli statici e riscrive alcuni costrutti sintatticamente (e.g. i cicli).

Tramite l'interprete è quindi possibile caricare, compilare ed eseguire programmi Picat, possibilmente anche modalità debug.

\paragraph{Esempio}\
\begin{verbatim}
> picat
Picat> compile(program)
Picat> load(program)
Picat> main.
\end{verbatim}

\subsection{Tipi di dato}

Picat è un linguaggio tipato dinamicamente: il controllo dei tipi avviene a runtime. Le variabili in Picat possono avere o non avere un valore. Una variabile è libera fintanto che non viene vincolata ad un valore (operazione di bounding), inoltre possono avere degli attributi rappresentati come mappa chiave-valore.

I tipi primitivi di Picat sono il numero intero, reale e l'atomo. Un atomo è un nome iniziante con lettera miniscola o una stringa quotata da apici singoli.

I tipi composti invece sono le liste \verb|[|$t_1, \ldots, t_n$\verb|]| e le strutture \verb|$s(|$t_1, \ldots, t_n$\verb|)|, dove $s$ è il nome della struct, ed $n$ è l'arità. Il dollaro viene impiegato per distinguere una chiamata di funzione da una struct. Picat inoltre mette a disposizione tipi composti speciali come \emph{strings}, \emph{arrays}, \emph{maps}, \emph{sets} e \emph{heaps}.

\paragraph{Esempio}\
\begin{verbatim}
Picat> V1 = X1, V2 = _ab, V3 = _       % variabili

Picat> N1 = 12, N2 = 0xf3, N3 = 1.0e8  % numeri

Picat> A1 = x1, A2 = ’_AB’, A3 = ''    % atomi

Picat> L = [a,b,c,d]                   % liste

Picat> write("hello"++"picat")
[h,e,l,l,o,p,i,c,a,t]                  % stringhe

Picat> print("hello"++"picat")
hellopicat

Picat> writef("%s","hello"++"picat")
hellopicat                             % write con formato

Picat> writef("%-5d %5.2f",2,2.0)
2
2.00                                   % write con formato

Picat> S = $point(1.0,2.0)             % struttura

Picat> S = new_struct(point,3)
S = point(_3b0,_3b4,_3b8)              % creazione di una struttura

Picat> A = {a,b,c,d}                   % array

Picat> A = new_array(3)
A = {_3b0,_3b4,_3b8}                   % creazione di un array

Picat> M = new_map([one=1,two=2])
M = (map)[two = 2,one = 1]             % creazione di una map

Picat> M = new_set([one,two,three])
M = (map)[two,one,three]               % creazione di un insieme

Picat> X = 1..2..10
X = [1,3,5,7,9]                        % ranges

Picat> X = 1..5
X = [1,2,3,4,5]
\end{verbatim}

Picat possiede una ricca libreria di funzioni di utilità sui tipi di dato che permettono, tra le altre cose, di verificare qual è il tipo di una variabile, convertire tipi ad altri tipi, aggiungere elementi ad un insieme, eccetera.

\subsection{Predicati}

I predicati sono una componente fondamentale di Picat. Un predicato ha esito positivo o negativo, a meno di eccezioni. Un predicato può esplorare tutte le soluzioni tramite il backtracking implementato in Picat.

In Picat i predicati sono definiti con regole di pattern-matching. Le regole utilizzabili per la definizione di un predicato sono $Head, Cond => Body$ e $Head, Cond\ ?=> Body$ che rappresentano rispettivamente la regola \emph{non-backtrackable} e \emph{backtrackable}. La testa $Head$ del predicato è $p(t_1, \ldots, t_n)$ con $p$ il nome del predicato e $n$ l'arità. Le condizioni $Cond$ sono goal opzionali che specificano l'applicabilità della regola. $Body$ è li corpo del predicato.
Quando una chiamata $C$ è applicabile, Picat riscrive $C$ in $Body$. Se la regola usata è \emph{non-backtrackable} allora la riscrittura è permanente, altrimenti il programma farà backtracking su $C$ se $Body$ fallisce e verrà provata la regola successiva.



\paragraph{Esempio (non backtrackable)}
\begin{verbatim}
membchk(X,[X|_]) => true.
membchk(X,[_|L]) => membchk(X,L)

Picat> membchk(X,[1,2,3]).
no
\end{verbatim}

\paragraph{Esempio (backtrackable)}
\begin{verbatim}
member(X,[Y|_]) ?=> X=Y.
member(X,[_|L]) => member(X,L).

Picat> member(X,[1,2,3])
X = 1;
X = 2;
X = 3;
no
\end{verbatim}

\subsection{Funzioni}

Picat permette di definire delle funzioni, ovvero oggetti che hanno sempre esito positivo e che ritornano un solo valore. La sintassi di una funzione è $Head, Cond = Result => Body$. Le funzioni in picat sono uno zucchero sintattico per un predicato cos' formato: $HeadResult, Cond => Body$ dove $HeadResult = p(t_1, \ldots, t_n, r)$.

\paragraph{Esempio}
\begin{verbatim}
fib(0)=F => F=1.
fib(1)=F => F=1.
fib(N)=F,N>1 => F=fib(N-1)+fib(N-2).

Picat> X = fib(8) 
X = 21
yes
\end{verbatim}

\subsection{Assegnamenti e Cicli}

Picat cerca di agevolare notevolmente i programmatori affini a linguaggi imperativi. Per questo motivo offre funzionalità come l'assegnamento, tipicamente non disponibile in un linguaggio logico,
e cicli, che nei linguaggi logici si realizzano con la ricorsione.

\subsubsection{Assegnamento}

Anche l'assegnamento, come altri comandi, è uno zucchero sintattico. Un assegnamento in Picat $X := Y$ viene gestito a tempo di compilazione creando nuovi nomi di variabile. Le nuove variabili conterrano il nuovo valore dopo l'assegnamento e verranno usati nella porzione di programma successiva all'asegnamento al posto della vecchia variabile.

\paragraph{Esempio}
\begin{verbatim}
test => X=0, X:=X+1, X:=X+1, write(X).
\end{verbatim}
ha come output $2$, e con la compilazione viene riscritto in
\begin{verbatim}
test => X=0, X1=X+1, X2=X1+1, write(X2).
\end{verbatim}
avente anch'esso output $2$.

\subsubsection{Cicli}

Picat supporta tre tipo di cicli: \verb|foreach|, \verb|while| e \verb|do-while|. Il \verb|foreach| viene usato per implementare un particolare tipo di ciclo su liste denominato \emph{list comprehension}.

\paragraph{Esempio}\
\begin{lstlisting}
% esempio di foreach
L = [2, 3, 5, 10],
foreach(I in L, J in 1 .. 10, J mod I != 0)
	printf("%d is not a multiple of %d%n", J, I)
end.

% esempio di while
I = 1,
while (I <= 9)
	println(I),
	I := I + 2
end.

% esempio di do while
J = 6,
do
	println(J),
	J := J + 1
while (J <= 5).
\end{lstlisting}

Mentre per i tipi di cicli più comuni la semantica è piuttosto ovvia, per le list comprehension la cosa è più interessante. Le list comprehension sono funzioni che servono a costruire una lista iterando valori di altre liste.

La list comprehension ha la seguente seguente sintassi
\begin{lstlisting}
[T : $E_1$ in $D_1$, $Cond_1$ , $\ldots$, $E_n$ in $D_n$ , $Cond_n$]
\end{lstlisting}

\paragraph{Esempio}\
\begin{lstlisting}
picat> L = [(A, I) : A in [a, b], I in 1 .. 2].
L = [(a , 1),(a , 2),(b , 1),(b , 2)]
\end{lstlisting}

\section{Funzionalità avanzate}
\label{sec:picat_advanced}

In questa sezione si da una panoramica delle funzionalità "avanzate" in Picat. Anche in questo caso si raccomanda al lettore l'approfondimento dei dettagli in \cite{PicatGuide}.

\subsection{Tabling}

Il tabling è un meccanismo di caching che permette di memorizzare la chiamata ad un predicato e relativo risultato per evitare cicli infiniti o per ridurre il costo computazione dovuto alla grossa ridondanza dei calcoli.

\paragraph{Esempio}\
\begin{lstlisting}
table
fib(0) = 1.
fib(1) = 1.
fib(N) = fib(N-1)+fib(N-2).
\end{lstlisting}
Senza tabling \verb|fib(N)| ha costo esponenziale in \verb|N|, con il tabling invece il costo è lineare.

Il tabling è abilitato usando la keyword \verb|table| prima della definizione del predicato.

\subsection{Moduli}

I moduli sono una funzionalità molto utile di Picat e permettono al programmatore un'organizzazione comoda del codice sorgente, suddivisa su più file (moduli, appunto).

Un modulo è un file sorgente con estensione \verb|.pi|. Un modulo inizia con la dichiarazione di se stesso nella forma \verb|module| $Name$, dove $Name$ corrisponde al nome del file.

Picat fornisce un sistema molto semplice di import, consentendo così di accedere a funzionalità di altri file sorgente. La sintassi per l'import è 
\begin{lstlisting}
import $Name_1, \ldots, Name_n$.
\end{lstlisting}

E' possibile chiamare predicati di un modulo specificando completamente il nome del predicato con \verb|m.p()|, dove \verb|m| è il nome del modulo e \verb|p| è il nome del predicato. E' consentito proibire l'utilizzo di un predicato da moduli esterni appondendo la keyword \verb|private| prima della definizione del predicato.

\subsection{Eccezioni}

Picat fornisce un semplice sistema di gestione delle eccezioni, con cui è possibile gestire eventi eccezionali ed errori non previsti.

La sintassi per il lancio delle eccezioni è 
\begin{lstlisting}
throw Exception
\end{lstlisting}
mentre la cattura e la gestione dell'eccezione si effettua tramite
\begin{lstlisting}
catch(Goal, Exception, Handler)
\end{lstlisting}

\subsection{Higher-Order Calls}
Un predicato o una funzione può essere di ordine superiore se riceve funzioni come argomenti. Alcuni predicati di ordine superiorie \emph{built-in} del linguaggio sono \verb|call|, \verb|apply| e \verb|find_all|. I predicati \verb|call| e \verb|apply| prendono in input un nome di funzione e lo eseguono con gli argomenti dati; \verb|apply| può ritornare un valore. Il predicato \verb|find_all| invece trova tutte le soluzioni della chiamata per la funzione in input.

Picat fornisce altri predicati di ordine superiore per la gestione delle eccezioni, l'esecuzione e alte utilità.

\paragraph{Esempio}
\begin{verbatim}
Picat> S=$member(X), call(S,[1,2,3])
X = 1;
X = 2;
X = 3;
no

Picat> L=findall(X,member(X,[1,2,3])).
L = [1,2,3]

Picat> Z=apply(’+’,1,2)
Z = 3
\end{verbatim}

\subsection{Action Rules}
Picat fornisce \emph{Action Rules} per descrivere attori event-driven. Un attore è un chiamata ad un predicato che può essere differita rispetto alla normale esecuzione ed è attivabile da eventi. Queste regole hanno sintassi $Head, Cond, \{Event\} => Body$, dove $Event$ è un insieme non vuoto di eventi separaati da virgola.

Gli attori possono essere assegnati a canali sui quali sono notificati gli eventi. Un canale è una variabile con degli attributi in grado di notificare eventi. Un canale può avere diverse porte, che specificano la visiblità dell'evento per qel canale. 

\subsection{Mappe Globali}
Picat fornisce tre tipi diversi di mappe globali, richiedibili durante l'esecuzione: mappe \emph{heap}, mappe \emph{globali} e \emph{tabelle}.

Queste mappe sono create non appena il sistema Picat si avvia. Possono essere consultate richiedendo a Picat una mappa e fornendo un \emph{ID} per la stessa. Le tre mappe differiscono per la modaltà di memorizzazione degli elementi e per il numero di mappe che possono essere richieste.

Queste mappe sono accessibili durante tutta l'esecuzione e sono quindi molto utili per memorizzare variabili globali.

\section{Picat vs. Prolog}
\label{sec:picat_picatvsprolog}

Sebbene Picat sia un linguaggio multi paradigma, esso è profondamente legato ai concetti di programmazione logica includendo \emph{variabili logiche}, \emph{unificazione} e \emph{backtracking}.
Come in Prolog, le variabili di Picat sono etichette a valori. Una variabile logica può essere legata a qualunque termine, includendo altre variabili logiche (una volta sola).

\begin{description}
\item[Unificazione e pattern-matching.] L'unificazione è l'operazione di base sia in Picat che in Prolog per effettuare il bound delle variabili a termini. Ma mentre in Prolog l'unificazione viene utilizzata anche nella risoluzione delle regole, in Picat viene impiegato il pattern-matching per dicidere se una regola è applicabile o meno. Ciò comporta alcune divergenze tra l'esecuzione della stessa regola in Prolog e in Picat.
Inoltre, l'operazione di pattern-matching sulle regole è molto più leggera rispetto all'unificazione.
\item[Batracking.] Anche Picat supporta nativamente il backtracking. In Prolog però ogni regola è implicitamente \emph{backtrackable} e si usa l'operatore \emph{cut} \verb|!| per il controllo. In Picat invece una regola è \emph{backtrackable} solo se esplicitamente dichiarato. Ciò permete al programmatore di capire a colpo d'occhio l'intenzione di una regola.
\item[Predicati dinamici.] Picat non supporta i predicati dinamici, mentre in Prolog è possibile asserire un predicato durante l'esecuzione, dando di fatto più flessibilità al linguaggio.
\item[Operatori definiti da utente.] In Picat non è possibile definire nessun operatore, mentre in Prolog è possibile estendere il set di operatore aggiungendone di nuovi.
\item[Costrutti.] La differenza più grossa tra i due linguaggi sono i costrutti che Picat fornisce per le list (e array) comprehensions, assegnamenti, cicli e funzioni, che per programmi di scripting e operazioni di modellizzazione rendono Picat più conveniente del Prolog.
\end{description}


%%% *******************************************************
%%% Solver CLP(SET) in Picat
\chapter{CLP(SET) in Picat}

\minitoc

INTRO\fixme{aggiungere intro con ref a sezioni sotto}

L'obiettivo principale del solver \clpset{} è risolvere formule insiemistiche del linguaggio \clpset{}. Il risultato può avere zero, una o più soluzioni ed il solver deve essere in grado di mostrarle tutte, se queste sono finite.

Il funzionamento del solver è quello descritto dallo pseudocodice in  \ref{subsec:lang_clpset_solver}. Per ricapitolare, il solver svolge queste tre azioni:
\begin{itemize}
\item rimpiazza i vincoli derivati con le corrispondenti formule \clpset{};
\item riduce la complessità sintattica dei vincoli primitivi applicando le regole di riscrittura corrette;
\item elimina gli insiemi che coinvolgono disuguaglianze.
\end{itemize} 
La formula finale ottenuta è semplificata e irriducibile, il che la rende equivalente alla formula originale.

\section{Notazione}

 \todo{da spostare in appendice}

Per semplificare l'implementazione si è deciso di adottare alcuni espedienti notazionali descritti dalla sezioni sottostanti.\footnote{La notazione impiegata in \clpset{} è descritta in \ref{sec:lang_clpset}.}. Ciò si è reso necessario per evitare di affrontare problemi non direttamente legati e potersi concentrare solamente sul solver.

\subsection{Formule}

La notazione adottata per la rappresentazione delle formule è la seguente:

\begin{table}[H]
\center
\begin{tabular}{ll}
\textbf{Linguaggio} & \textbf{Notazione} \\
\clpset{} & $T_1 \land T_2 \land \ldots \land T_n$ \\
Picat & \verb|[| $T_1, T_2, \ldots, T_n$\verb|]| \\
\end{tabular}
\end{table}

\subsection{Operazioni primitive}

Le operazioni primitive di \clpset{} sono spesso espresse tramite simboli (e.g., $=, \neq, \ldots$). La notazione adottata è la seguente:

\begin{table}[H]
\center
\begin{tabular}{l l}
\textbf{Linguaggio} & \textbf{Notazione} \\
\clpset{} & $T_1 = T_2$ \\
Picat & \verb|[eq(| $T_1, T_2$ \verb|)]| \\
\end{tabular}
\end{table}

\subsection{Insiemi}

Gli insiemi in \clpset{} sono rappresentati tramite la funzione $\{ \cdot \mid \cdot \}$.

\begin{table}[H]
\center
\begin{tabular}{l l}
\textbf{Linguaggio} & \textbf{Notazione} \\
\clpset{} & $\{ T_1, T_2, \ldots, T_n \mid X \}$ \\
Picat & \verb|[| $T_1, T_2, \ldots, T_n \mid X$ \verb|]| \\
\end{tabular}
\end{table}

\section{Il sistema}

\subsection{Moduli}

Il progetto di implementazione di \clpset{} in Picat si articola in diversi moduli: alcuni realizzano funzioni di utilità molto vicine al solver, altri sono moduli di corredo, atti a gestire aspetti non legati direttamente alla risoluzione di formule insiemistiche.

I moduli identificati e realizzati sono:
\begin{itemize}
\item \verb|solver|: il modulo principale che realizza la risoluzione delle formule;
\item \verb|lset|: il modulo contenente l'interfaccia e l'implementazione degli insiemi nei termini di \clpset{};
\item \verb|commands|: il modulo di gestione dell'interfaccia utente;
\item \verb|global|: il modulo per la gestione delle variabili globali;
\item \verb|log_h|: il modulo per la gestione dei log;
\item \verb|prompt|: il modulo di gestione I/O;
\item \verb|assert|: il modulo di utilità l'implementazione di \emph{unit tests}.
\end{itemize}

\subsection{Tests}
 \todo{Aggiungere test}

\section{Il solver}

\subsection{Predicato solve/2}

Il predicato \verb|solve/2| riceve in input una formula, e restituisce in output la formula risolta. Questo predicato scandisce ogni termine della formula congiuntiva data in input e cerca di ridurla generando una nuova formula (possibilmente nulla) e un insieme di vincoli (possibilmente vuoto).

\paragraph{Implementazione} Il predicato \verb|solve/2| risolve la formula congiuntiva in input $C$ e riscrive ogni termine in forma più semplice, creando un nuovo constraint store $CN$. Se le riscritture applicate rendono il constraint store uguale alla formula in input allora si è raggiunto un \textbf{punto fisso} e si termina l'esecuzione con risultato $CC = CN$, altrimenti si prosegue cercando di risolvere il nuovo constraint store $solve(CN, CC)$.
\begin{verbatim}
%% solve(C, CC) is det

solve(C, CC) =>
    CN = [],
    foreach (T in C)
        sat(T, C1), 
        CN := CN ++ C1,
    end,
    CN := CN.flatten(),
   
    if C == CN 
    then CC = CN 
    else solve(CN, CC)
    end.
\end{verbatim}

\paragraph{Utilizzo} Il predicato \verb|solve/2| può essere usato come un API, esposta dal modulo \emph{solver}. Il modulo \emph{commands} di fatto usa questo predicato per risolvere una formula.
\begin{verbatim}
%% doSolve(+FormulaString) is semidet

doSolve(FormulaString) ?=>
    parse_term(FormulaString, Term, Vars),
    solve(Term, Res),
    println("Vars: " ++ Vars.to_string),
    println("Constraints: " ++ Res.to_string).
    nl,
    A = confirm("Another solution?"),
    if A == 1 then fail end.
doSolve(_) => println("no!").
\end{verbatim}

Il predicato \verb|solve/2| visto come API è utile anche nell'effetuare gli \emph{unit tests}. L'esempio riportato, seppur poco interessante dal punto di vista della formula, mostra l'utilizzo di \verb|solve/2| per verificare la correttezza della risoluzione.
\begin{verbatim}
setlog_eq1_1_test ?=>
    A = new_assert("setlog_eq1_1_test"),
    F = [$eq(1, 1)],
    solve(F, FF),
    A.assert_equal([], FF).
setlog_eq1_1_test => A = new_assert("setlog_eq1_1_test"), A.fail().
\end{verbatim}

\subsection{Predicato sat/2}
Il predicato \verb|sat/2| combinato con \verb|rule/2| seleziona la regola da applicare in base al termine dato, distinguendo se l'operazione che si vuole compiere è $=, \neq, \in, \ldots$, e applicando le giuste regole di riscrittura. 

\paragraph{Implementazione} \verb|sat/2| gestisce l'input, mentre \verb|rule/2| effettua il dispatching della regola giusta. Notare come il predicato \verb|rule/2| sia pensato per essere estendibile.
\begin{verbatim}
%% sat(F, FF) is det

sat(F, FF), F == [] => FR = [].
sat(F, FF) => rule(F, FF).


%% rule(F, R) is det

rule(eq(T1, T2), R)  => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(or(T1, T2), R)  => or(T1, T2, R).
rule(or(T), R)       => or(T, R).
rule(insl(X, S), R)  => insl(X, S, R).
rule(nin(X, S), R)   => nin(X, S, R).
rule(contains(S, X), R)    => contains(S, X, R).
rule(union(S1, S2, S3), R) => union(S1, S2, S3, R).
rule(disj(S1, S2), R)      => disj(S1, S2, R).
rule(subset(S1, S2), R)    => subset(S1, S2, R).
\end{verbatim}

Le regole implementate sono un sottoinsieme di quelle descritte in \cite{Rossi18}.

\subsection{Regole di riscrittura}

Nel modulo \emph{solver}, oltre ai predicati descritti in precedenza e a qualche predicato ausiliario, sono presenti i predicati che implementano le regole di riscrittura:
\begin{itemize}
\item \verb|eq/3| ($=$);
\item \verb|neq/3| ($\neq$);
\item \verb|insl/3| ($\in$);
\item \verb|contains/3| ($contains$);
\item \verb|union/3| ($\cup$);
\item \verb|disj/3| ($||$);
\item \verb|subset/3| ($\subset$);
\item \verb|inters/3| ($\cap$);
\item \verb|diff/3| ($\setminus$);
\end{itemize}

Nelle sezioni successive sono riportate le implementazioni delle regole di riscrittura. Si può notare che la descrizione matematica in \cite{Rossi18} è molto vicina all'implementazione.

\subsubsection{eq/3}

\begin{verbatim}
eq(T1, T2, R),  T1 == T2 =>                                        % 1
    log_d_vv("eq :: eq_1"),
    R = [].

eq(T1, T2, R), nonvar(T1), var(T2) =>                              % 2
    log_d_vv("eq :: eq_2"),
    R = [ $eq(T2, T1) ].

eq(T1, T2, R), 
        var(T1), T2.is_lset(),
	    not occur_check(T1, T2.lset_head()),
        T1 == T2.lset_rest() =>                                    % 3
    log_d_vv("eq :: eq_3"),
    YSetNew = new_lset(T2.lset_head(),_N),
    R = [ $eq(T1, YSetNew) ].

eq(T1, T2, _R), 
        var(T1),
        occur_check(T1, T2) =>                                     % 4
    log_d_vv("eq :: eq_4"),
    fail.  % sic.

eq(T1, T2, R), 
        var(T1) =>                                                 % 5
    log_d_vv("eq :: eq_5"),
    R = [], T1 = T2.

eq(T1, T2, _R), 
        struct(T1), struct(T2), 
        T1.name() !== T2.name() =>                                 % 6
    log_d_vv("eq :: eq_6"),
    fail.  % sic.

eq(T1@[X|Xs], T2, R), 
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7a
    log_d_vv("eq :: eq_7a"),

    YH = T2.lset_head(),                   % head of T2.
    foreachnd_slice(YH, YElem, YSlice),    % get the j-th element nondet.
    YRest = T2.lset_rest(),                % rest of T2.
    YSetSliced = new_lset(YSlice, YRest),  % build T2 without j-th elem.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(Xs, YSetSliced) ],

    R = R1 ++ R2.

eq(T1@[X|_], T2, R), 
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7b
    log_d_vv("eq :: eq_7b"),

    YH = T2.lset_head(),                   % head of T2.
    foreachnd_slice(YH, YElem, YSlice),    % get the j-th element nondet.
    YRest = T2.lset_rest(),                % rest of T2.
    YSetSliced = new_lset(YSlice, YRest),  % build T2 without j-th elem.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(T1, YSetSliced) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2, R),
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() ?=>                       % 7c
    log_d_vv("eq :: eq_7c"),

    % no slice for T2, only Y elem.
    YH = lset_head(T2),              % head of T2.
    foreachnd_slice(YH, YElem, _),   % get the j-th element nondet.

    R1 = [ $eq(X, YElem) ],
    R2 = [ $eq(Xs, T2) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2, R),
        T1.is_lset(), T2.is_lset(),
        T1.lset_rest() == T2.lset_rest() =>                        % 7d
    log_d_vv("eq :: eq_7d"),

    XRest = lset_rest(T1),

    XHeadSlice = lset_head(Xs),
    XSetNew = new_lset(XHeadSlice, N),

    YHead = T2.lset_head(),
    YSetNew = new_lset(YHead, N),

    R1 = [ $eq(XRest, [X|N]) ],
    R2 = [ $eq(XSetNew, YSetNew) ],

    R = R1 ++ R2.

eq(T1@[X|Xs], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8a
    log_d_vv("eq :: eq_8a"),
    R = [ $eq(X,Y), $eq(Xs, Ys) ].

eq(T1@[X|_], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8b
    log_d_vv("eq :: eq_8b"),
    R = [ $eq(X,Y), $eq(T1, Ys) ].

eq(T1@[X|Xs], T2@[Y|_], R),
        T1.is_lset(), T2.is_lset() ?=>                             % 8c
    log_d_vv("eq :: eq_8c"),
    R = [ $eq(X,Y), $eq(Xs, T2) ].

eq(T1@[X|Xs], T2@[Y|Ys], R),
        T1.is_lset(), T2.is_lset() =>                              % 8d
    log_d_vv("eq :: eq_8d"),
    R = [  
        $eq( Xs,  [Y|N] ),  
        $eq( [X|N],  Ys ) 
    ].

eq(T1, T2, R),
        T1.struct(), T2.struct(),
        T1.name() == T2.name(),
        T1.arity() == T2.arity() =>                                % 9
    log_d_vv("eq :: eq_9"),
    RR = [],
    foreach(I in 1..T1.arity())
        RR := RR ++ [  $eq( T1[I], T2[I] )  ]
    end,
    R = RR.
\end{verbatim}

\chapter{Dettagli implementativi}
TODO

\chapter{Uso del solver \clpset{} da Picat}
In questa sezione viene dato un esempio di caso d'uso del solver \clpset{} da Picat.

\chapter{Esensioni al solver di base}
TODO

\chapter{Conclusione e lavori futuri}
TODO

\printbibliography

\end{document}